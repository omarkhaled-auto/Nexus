---
phase: 04-event-system
plan: 03
type: execute
depends_on: ["04-01", "04-02"]
files_modified: [src/events/IPCBridge.ts, src/events/IPCBridge.test.ts, src/main/ipc/eventHandlers.ts, src/events/index.ts]
---

<objective>
Implement IPC bridge for event forwarding between Electron main and renderer processes.

Purpose: Enable the React UI (renderer) to receive real-time events from the backend (main process) for live updates.
Output: IPCBridge that forwards events across process boundaries with proper serialization.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-event-system/04-01-SUMMARY.md
@.planning/phases/04-event-system/04-02-SUMMARY.md
@src/events/EventBus.ts
@src/types/events.ts

**Tech stack available:** Electron, TypeScript, Vitest
**Established patterns:** EventBus singleton, onAny subscription

**Electron IPC Context:**
- Main process: Full Node.js access, runs backend services
- Renderer process: Chromium, runs React UI
- Communication via ipcMain/ipcRenderer with contextBridge for security
- Events must be serializable (no functions, circular refs)

**Architecture requirement:**
Events emitted in main process should be forwarded to renderer for UI updates.
UI components subscribe to events via a client-side EventBus or store updates.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IPCBridge for main process</name>
  <files>src/events/IPCBridge.ts, src/events/IPCBridge.test.ts</files>
  <action>
    Create IPCBridge class for main process that:
    1. Subscribes to EventBus using onAny()
    2. Forwards events to all renderer windows via webContents.send()
    3. Serializes events (Date -> ISO string, remove non-serializable)
    4. Handles window lifecycle (add/remove windows)
    5. Methods:
       - `constructor(eventBus: IEventBus)` - inject EventBus
       - `registerWindow(window: BrowserWindow): void` - add window
       - `unregisterWindow(window: BrowserWindow): void` - remove window
       - `start(): void` - begin forwarding events
       - `stop(): void` - stop forwarding
       - `getWindowCount(): number` - registered window count

    Event serialization:
    ```typescript
    function serializeEvent(event: NexusEvent): SerializedEvent {
      return {
        ...event,
        timestamp: event.timestamp.toISOString(),
        // payload should already be serializable
      };
    }
    ```

    IPC channel: 'nexus:event'

    Tests to write (mock BrowserWindow.webContents):
    - Forwards events to registered windows
    - Serializes Date to ISO string
    - Does not forward when stopped
    - Handles window close gracefully
    - Multiple windows all receive events
    - Unregister removes window from forwarding
    - getWindowCount accurate
  </action>
  <verify>pnpm test -- --testNamePattern "IPCBridge" passes (10+ tests)</verify>
  <done>IPCBridge forwards serialized events to renderer windows</done>
</task>

<task type="auto">
  <name>Task 2: Create IPC event handlers for main process</name>
  <files>src/main/ipc/eventHandlers.ts</files>
  <action>
    Create IPC handler setup for main process:
    1. Create src/main/ipc/ directory if not exists
    2. Implement setupEventHandlers(ipcMain, eventBus, ipsBridge) function
    3. Register handlers:
       - 'nexus:subscribe' - renderer requests subscription (returns ack)
       - 'nexus:unsubscribe' - renderer cancels subscription
       - 'nexus:getHistory' - renderer requests event history
       - 'nexus:emit' - renderer emits event to main (for UI actions)

    Handler implementations:
    ```typescript
    // Renderer can request recent events on connect
    ipcMain.handle('nexus:getHistory', async (event, count: number) => {
      return eventHistory.getLast(count).map(serializeEvent);
    });

    // Renderer can emit events (e.g., user actions)
    ipcMain.handle('nexus:emit', async (event, serializedEvent) => {
      eventBus.emit(serializedEvent.type, deserializePayload(serializedEvent));
    });
    ```

    Note: Since this is main process code that uses ipcMain, tests will mock ipcMain.
    The actual Electron integration will be verified in integration tests later.
  </action>
  <verify>File exists with correct handler registrations, TypeScript compiles</verify>
  <done>IPC handlers registered for event system communication</done>
</task>

<task type="auto">
  <name>Task 3: Create preload script types for renderer</name>
  <files>src/events/preload.ts, src/events/index.ts</files>
  <action>
    Create type definitions and preload script exports:

    1. Create src/events/preload.ts with:
       ```typescript
       // Types for renderer-side event access via contextBridge
       export interface NexusEventAPI {
         onEvent(callback: (event: SerializedEvent) => void): () => void;
         getHistory(count?: number): Promise<SerializedEvent[]>;
         emit(type: EventType, payload: unknown): Promise<void>;
       }

       // Declare window augmentation
       declare global {
         interface Window {
           nexusEvents: NexusEventAPI;
         }
       }
       ```

    2. Create setupPreload() function that returns contextBridge-safe object:
       ```typescript
       export function createPreloadAPI(ipcRenderer: IpcRenderer): NexusEventAPI {
         return {
           onEvent: (callback) => {
             const handler = (_: IpcRendererEvent, event: SerializedEvent) => callback(event);
             ipcRenderer.on('nexus:event', handler);
             return () => ipcRenderer.removeListener('nexus:event', handler);
           },
           getHistory: (count = 100) => ipcRenderer.invoke('nexus:getHistory', count),
           emit: (type, payload) => ipcRenderer.invoke('nexus:emit', { type, payload }),
         };
       }
       ```

    3. Update src/events/index.ts to export preload types and function

    This enables type-safe event access from renderer:
    ```typescript
    // In React component
    window.nexusEvents.onEvent((event) => {
      console.log('Event:', event.type, event.payload);
    });
    ```
  </action>
  <verify>TypeScript compiles, exports available from @/events</verify>
  <done>Preload types and API defined for renderer access</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm test -- --testNamePattern "IPC"` - IPC tests pass
- [ ] `pnpm typecheck` - no TypeScript errors
- [ ] `pnpm eslint src/events/ src/main/` - no lint errors
- [ ] IPCBridge can forward events to mock windows
- [ ] Preload API types exported
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- IPCBridge forwards events to renderer windows
- IPC handlers set up for bidirectional communication
- Type-safe preload API defined
- Phase 4 complete: Event system ready for use
</success_criteria>

<output>
After completion, create `.planning/phases/04-event-system/04-03-SUMMARY.md`:

# Phase 04-03: IPC Bridge Summary

**[Substantive one-liner]**

## Accomplishments
- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified
- `path/to/file.ts` - Description

## Decisions Made
[Key decisions and rationale, or "None"]

## Issues Encountered
[Problems and resolutions, or "None"]

## Phase 4 Complete
Event system ready:
- EventBus: Type-safe pub/sub singleton
- EventHistory: Queryable event storage
- EventLogger: Configurable logging
- IPCBridge: Main/renderer communication

## Next Phase
Ready for Phase 5: Agent Core
</output>
