---
phase: 04-event-system
plan: 01
type: tdd
depends_on: []
files_modified: [src/events/EventBus.ts, src/events/EventBus.test.ts, src/events/types.ts, src/events/index.ts]
---

<objective>
Implement type-safe EventBus singleton with pub/sub pattern using TDD.

Purpose: Create the core event-driven communication infrastructure that enables decoupled communication between all Nexus layers.
Output: Working EventBus with emit, subscribe, unsubscribe, and wildcard subscription capabilities with comprehensive test coverage.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
./.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@src/types/events.ts

**Tech stack available:** TypeScript, Vitest
**Established patterns:** TDD (RED-GREEN-REFACTOR), duck typing for mocks

**Constraining decisions:**
- Phase 03-01: Duck typing for SDK errors enables clean mocking
- Phase 03-02: Tool loop pattern establishes async execution patterns

**Event types already defined:**
The `src/types/events.ts` file contains 48 event types with full payload definitions. This plan implements the EventBus that uses these types.

**Interface to implement (from architecture docs):**
```typescript
export interface IEventBus {
  emit<T extends EventType>(type: T, payload: EventPayload<T>): void;
  on<T extends EventType>(type: T, handler: EventHandler<T>): Unsubscribe;
  once<T extends EventType>(type: T, handler: EventHandler<T>): Unsubscribe;
  off<T extends EventType>(type: T, handler: EventHandler<T>): void;
  onAny(handler: WildcardHandler): Unsubscribe;
  offAny(handler: WildcardHandler): void;
  removeAllListeners(type?: EventType): void;
  listenerCount(type: EventType): number;
}
```
</context>

<feature>
  <name>EventBus Core Implementation</name>
  <files>src/events/types.ts, src/events/EventBus.ts, src/events/EventBus.test.ts, src/events/index.ts</files>
  <behavior>
    EventBus is a singleton that manages typed event subscriptions.

    **emit(type, payload)**:
    - Creates NexusEvent with id, timestamp, source
    - Calls all registered handlers for that event type
    - Calls all wildcard handlers
    - Does NOT throw if no handlers registered

    **on(type, handler) -> Unsubscribe**:
    - Registers handler for event type
    - Returns unsubscribe function
    - Same handler can be registered multiple times (each fires)
    - Handler receives full NexusEvent object

    **once(type, handler) -> Unsubscribe**:
    - Like on() but auto-removes after first call
    - Returns unsubscribe function (can cancel before triggered)

    **off(type, handler)**:
    - Removes specific handler from event type
    - Silently ignores if handler not registered

    **onAny(handler) -> Unsubscribe**:
    - Registers wildcard handler that receives ALL events
    - Returns unsubscribe function

    **offAny(handler)**:
    - Removes specific wildcard handler

    **removeAllListeners(type?)**:
    - If type provided: removes all handlers for that type
    - If no type: removes ALL handlers (including wildcards)

    **listenerCount(type)**:
    - Returns count of handlers for specific event type
    - Does NOT count wildcard handlers

    **Test cases:**
    - emit() calls registered handlers with correct event shape
    - emit() with no handlers doesn't throw
    - on() returns working unsubscribe function
    - once() handler only fires once
    - once() unsubscribe works before trigger
    - off() removes correct handler
    - off() with unregistered handler doesn't throw
    - onAny() receives all event types
    - offAny() removes wildcard handler
    - removeAllListeners() clears specific type
    - removeAllListeners() clears all when no arg
    - listenerCount() returns correct count
    - Multiple handlers for same event all fire
    - Handler errors don't break other handlers
    - Singleton pattern returns same instance
    - Event has correct id, timestamp, type, payload
  </behavior>
  <implementation>
    Create src/events/ directory structure:
    1. types.ts - Re-export from src/types/events.ts plus internal types (WildcardHandler, Unsubscribe)
    2. EventBus.ts - Singleton class implementation
    3. EventBus.test.ts - TDD tests
    4. index.ts - Module exports

    Use Map<EventType, Set<Handler>> for type-specific handlers.
    Use Set<WildcardHandler> for wildcard handlers.
    Generate event IDs with crypto.randomUUID() or nanoid pattern.
    Wrap handler calls in try-catch to prevent one handler breaking others.
  </implementation>
</feature>

<verification>
- [ ] `pnpm test -- --testNamePattern "EventBus"` - all tests pass (target: 20+ tests)
- [ ] `pnpm typecheck` - no TypeScript errors
- [ ] `pnpm eslint src/events/` - no lint errors
</verification>

<success_criteria>
- EventBus singleton implemented with full IEventBus interface
- All pub/sub operations work correctly
- Type safety maintained (EventPayload<T> for handlers)
- Error isolation (one handler failure doesn't break others)
- 20+ tests covering all behavior
- RED-GREEN-REFACTOR commits present
</success_criteria>

<output>
After completion, create `.planning/phases/04-event-system/04-01-SUMMARY.md`:

# Phase 04-01: EventBus Core Summary

**[Substantive one-liner]**

## TDD Metrics
| Component | Tests | Status |
|-----------|-------|--------|
| EventBus | N | PASS/FAIL |

## RED Phase
- What tests written, why they failed

## GREEN Phase
- What implementation made them pass

## REFACTOR Phase
- What cleanup done (if any)

## Commits
- List of commits produced

## Files Created
- path/to/file.ts - Description

## Next Step
Ready for 04-02-PLAN.md (Event Logging & History)
</output>
