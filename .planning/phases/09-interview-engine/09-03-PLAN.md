---
phase: 09-interview-engine
plan: 03
type: execute
depends_on: ["09-02"]
files_modified: [src/interview/InterviewSessionManager.ts, src/interview/InterviewSessionManager.test.ts, src/main/ipc/interview-handlers.ts, src/preload/interview-api.ts, src/interview/index.ts]
---

<objective>
Build InterviewSessionManager for persistence and IPC handlers to connect Interview Engine with the Phase 6 UI.

Purpose: Enable session persistence, resume from checkpoint, auto-save, and expose interview API to renderer process.
Output: Working persistence with ~8 tests, IPC handlers integrated with existing UI.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-interview-engine/09-CONTEXT.md
@.planning/phases/09-interview-engine/09-RESEARCH.md
@.planning/phases/09-interview-engine/09-01-SUMMARY.md
@.planning/phases/09-interview-engine/09-02-SUMMARY.md

# Source files to reference
@src/interview/InterviewEngine.ts
@src/interview/types.ts
@src/persistence/database/DatabaseClient.ts
@src/main/ipc/index.ts
@src/preload/index.ts
@src/renderer/src/stores/interviewStore.ts

**Tech stack available:** SQLite/Drizzle, IPC pattern from Phase 5-8
**Established patterns:** IPC handlers in main/, preload exposes API, renderer uses nexusAPI

**From CONTEXT.md - Session persistence:**
- Auto-save every 30 seconds
- Resume from checkpoint on restart
- Export to RequirementsDB format

**From Phase 6 - interviewStore already has:**
- messages, requirements, stage, isInterviewing
- Event emission via nexusAPI methods
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create InterviewSessionManager</name>
  <files>src/interview/InterviewSessionManager.ts, src/interview/InterviewSessionManager.test.ts</files>
  <action>
    **InterviewSessionManager class:**
    ```typescript
    interface InterviewSessionManagerOptions {
      db: DatabaseClient;
      eventBus: EventBus;
      logger?: Logger;
      autoSaveInterval?: number; // Default 30000ms
    }
    ```

    **Storage approach:** Store sessions in projects.settings JSON column (following Phase 2 pattern) or create dedicated interview_sessions table. Prefer settings JSON for simplicity unless complex queries needed.

    **Methods:**
    - `save(session: InterviewSession): Promise<void>` - Persist session to DB
    - `load(sessionId: string): Promise<InterviewSession | null>` - Load from DB
    - `loadByProject(projectId: string): Promise<InterviewSession | null>` - Get active session for project
    - `delete(sessionId: string): Promise<void>` - Remove session
    - `startAutoSave(session: InterviewSession): void` - Begin 30s interval
    - `stopAutoSave(): void` - Clear interval
    - `exportToRequirementsDB(session: InterviewSession, requirementsDB: RequirementsDB): Promise<number>` - Bulk export

    **Auto-save implementation:**
    ```typescript
    private autoSaveInterval: NodeJS.Timeout | null = null;

    startAutoSave(session: InterviewSession): void {
      this.stopAutoSave();
      this.autoSaveInterval = setInterval(() => {
        void this.save(session);
        this.eventBus.emit('interview:saved', { sessionId: session.id });
      }, this.options.autoSaveInterval ?? 30000);
    }

    stopAutoSave(): void {
      if (this.autoSaveInterval) {
        clearInterval(this.autoSaveInterval);
        this.autoSaveInterval = null;
      }
    }
    ```

    **Session serialization:**
    - Convert Date fields to ISO strings for JSON storage
    - Parse back to Date on load
    - Handle messages array with timestamps

    **Tests (~8):**
    - save() persists session to database
    - load() retrieves session by ID
    - load() returns null for unknown session
    - loadByProject() returns active session for project
    - loadByProject() returns null when no active session
    - delete() removes session from database
    - startAutoSave() triggers periodic saves
    - exportToRequirementsDB() creates requirements in DB with source traceability

    Update index.ts to export InterviewSessionManager.
  </action>
  <verify>npm test -- src/interview/InterviewSessionManager.test.ts</verify>
  <done>InterviewSessionManager with 8 passing tests, auto-save working</done>
</task>

<task type="auto">
  <name>Task 2: Create IPC handlers and preload API</name>
  <files>src/main/ipc/interview-handlers.ts, src/preload/interview-api.ts, src/main/ipc/index.ts, src/preload/index.ts</files>
  <action>
    **IPC handlers (src/main/ipc/interview-handlers.ts):**
    ```typescript
    // Following same pattern as existing handlers
    import { ipcMain } from 'electron';
    import type { InterviewEngine } from '@/interview';
    import type { InterviewSessionManager } from '@/interview';

    export function registerInterviewHandlers(
      interviewEngine: InterviewEngine,
      sessionManager: InterviewSessionManager
    ): void {
      // Start new interview
      ipcMain.handle('interview:start', async (_, projectId: string) => {
        const session = interviewEngine.startSession(projectId);
        sessionManager.startAutoSave(session);
        return session;
      });

      // Send message
      ipcMain.handle('interview:sendMessage', async (_, sessionId: string, message: string) => {
        const result = await interviewEngine.processMessage(sessionId, message);
        return result;
      });

      // Get session
      ipcMain.handle('interview:getSession', async (_, sessionId: string) => {
        return interviewEngine.getSession(sessionId);
      });

      // Resume session
      ipcMain.handle('interview:resume', async (_, sessionId: string) => {
        const session = await sessionManager.load(sessionId);
        if (session) {
          sessionManager.startAutoSave(session);
        }
        return session;
      });

      // End interview
      ipcMain.handle('interview:end', async (_, sessionId: string) => {
        interviewEngine.endSession(sessionId);
        sessionManager.stopAutoSave();
        const session = interviewEngine.getSession(sessionId);
        if (session) {
          await sessionManager.save(session);
        }
      });

      // Pause interview
      ipcMain.handle('interview:pause', async (_, sessionId: string) => {
        interviewEngine.pauseSession(sessionId);
        sessionManager.stopAutoSave();
        const session = interviewEngine.getSession(sessionId);
        if (session) {
          await sessionManager.save(session);
        }
      });
    }
    ```

    **Preload API (src/preload/interview-api.ts):**
    ```typescript
    import { ipcRenderer } from 'electron';
    import type { InterviewSession, ProcessMessageResult } from '@/interview';

    export const interviewAPI = {
      start: (projectId: string): Promise<InterviewSession> =>
        ipcRenderer.invoke('interview:start', projectId),

      sendMessage: (sessionId: string, message: string): Promise<ProcessMessageResult> =>
        ipcRenderer.invoke('interview:sendMessage', sessionId, message),

      getSession: (sessionId: string): Promise<InterviewSession | null> =>
        ipcRenderer.invoke('interview:getSession', sessionId),

      resume: (sessionId: string): Promise<InterviewSession | null> =>
        ipcRenderer.invoke('interview:resume', sessionId),

      end: (sessionId: string): Promise<void> =>
        ipcRenderer.invoke('interview:end', sessionId),

      pause: (sessionId: string): Promise<void> =>
        ipcRenderer.invoke('interview:pause', sessionId),
    };
    ```

    **Update existing files:**

    1. **src/main/ipc/index.ts** - Add import and registration:
    ```typescript
    import { registerInterviewHandlers } from './interview-handlers';
    // In setup function:
    registerInterviewHandlers(interviewEngine, sessionManager);
    ```

    2. **src/preload/index.ts** - Add to contextBridge expose:
    ```typescript
    import { interviewAPI } from './interview-api';
    // Add to nexusAPI:
    interview: interviewAPI,
    ```

    3. **Update Window type declaration** (if needed):
    ```typescript
    interface NexusAPI {
      // ... existing
      interview: typeof interviewAPI;
    }
    ```

    **Note:** This connects the backend InterviewEngine to the existing Phase 6 UI. The UI (interviewStore, ChatPanel, etc.) can now call `window.nexusAPI.interview.sendMessage()` instead of simulating responses.
  </action>
  <verify>npm run build && npm run typecheck</verify>
  <done>IPC handlers registered, preload API exposed, types aligned</done>
</task>

<task type="auto">
  <name>Task 3: Wire up initialization and verify integration</name>
  <files>src/main/index.ts, src/interview/index.ts</files>
  <action>
    **Update main process initialization (src/main/index.ts):**

    1. Import interview engine components
    2. Create InterviewEngine instance with dependencies
    3. Create InterviewSessionManager instance
    4. Pass to IPC handler registration

    ```typescript
    import { InterviewEngine, InterviewSessionManager } from '@/interview';
    import { ClaudeClient } from '@/llm';
    import { RequirementsDB } from '@/persistence/requirements';
    import { EventBus } from '@/orchestration/event-bus';

    // In initialization:
    const claudeClient = new ClaudeClient({ apiKey: process.env.ANTHROPIC_API_KEY! });
    const interviewEngine = new InterviewEngine({
      llmClient: claudeClient,
      requirementsDB,
      eventBus,
      logger,
    });
    const sessionManager = new InterviewSessionManager({
      db: databaseClient,
      eventBus,
      logger,
    });

    registerInterviewHandlers(interviewEngine, sessionManager);
    ```

    **Verify full integration:**
    - Build succeeds
    - TypeScript types align between main/preload/renderer
    - No circular dependencies

    **Update interview/index.ts** to export all:
    ```typescript
    export * from './types';
    export * from './RequirementExtractor';
    export * from './QuestionGenerator';
    export * from './InterviewEngine';
    export * from './InterviewSessionManager';
    export * from './prompts/interviewer';
    export * from './prompts/extractor';
    ```
  </action>
  <verify>npm run build && npm run typecheck</verify>
  <done>Interview engine fully wired, build passes, ready for UI integration</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm test -- src/interview/` passes all tests (~45+ total)
- [ ] `npm run build` succeeds without errors
- [ ] `npm run typecheck` passes
- [ ] InterviewSessionManager persists and loads sessions
- [ ] IPC handlers registered and callable
- [ ] Main process creates InterviewEngine with real dependencies
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- ~8 new tests for InterviewSessionManager
- IPC bridge connects backend to Phase 6 UI
- Auto-save working at 30s interval
- Phase 9 complete - Interview Engine backend fully operational
</success_criteria>

<output>
After completion, create `.planning/phases/09-interview-engine/09-03-SUMMARY.md`:

# Plan 09-03: InterviewSessionManager + IPC Summary

**[One-liner: what shipped]**

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- `src/interview/InterviewSessionManager.ts` - Session persistence
- `src/interview/InterviewSessionManager.test.ts` - 8 tests
- `src/main/ipc/interview-handlers.ts` - IPC handlers
- `src/preload/interview-api.ts` - Preload API
- `src/main/ipc/index.ts` - Handler registration
- `src/preload/index.ts` - API exposure
- `src/main/index.ts` - Initialization
- `src/interview/index.ts` - Barrel export

## Decisions Made

[Key decisions and rationale]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 9 complete. Ready for Phase 10 (Human Checkpoints).
</output>
