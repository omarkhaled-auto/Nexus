---
phase: 09-interview-engine
plan: 01
type: tdd
depends_on: []
files_modified: [src/interview/RequirementExtractor.ts, src/interview/RequirementExtractor.test.ts, src/interview/types.ts]
---

<objective>
Build RequirementExtractor - THE HERO of Phase 9 - using TDD methodology.

Purpose: Extract structured requirements from natural language conversation with category tagging, priority assignment, confidence scoring, and source traceability.
Output: RequirementExtractor class with ~10 tests covering parsing, categorization, and confidence scoring.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
@./.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-interview-engine/09-CONTEXT.md
@.planning/phases/09-interview-engine/09-RESEARCH.md

# Relevant prior work
@.planning/phases/02-persistence/02-01-SUMMARY.md
@.planning/phases/03-llm-agents/03-01-SUMMARY.md

# Source files to reference
@src/persistence/requirements/RequirementsDB.ts
@src/llm/clients/ClaudeClient.ts
@src/renderer/src/types/interview.ts

**Tech stack available:** ClaudeClient, RequirementsDB, nanoid, zod
**Established patterns:** XML tag extraction, custom error classes, duck typing for mocks

**From RESEARCH.md - Don't hand-roll:**
- Requirement categorization → use Claude with XML tags
- Confidence scoring → use Claude's self-assessment
- Similarity detection → use existing `calculateSimilarity` in RequirementsDB

**From RESEARCH.md - Key pattern:**
```typescript
// XML tag extraction pattern
const EXTRACTION_PROMPT = `
For each requirement found, output in this format:
<requirement>
  <text>The requirement description</text>
  <category>functional|non_functional|technical|constraint|assumption</category>
  <priority>must|should|could|wont</priority>
  <confidence>0.0-1.0</confidence>
  <area>authentication|payments|ui|etc</area>
</requirement>
`;
```
</context>

<feature>
  <name>RequirementExtractor</name>
  <files>src/interview/types.ts, src/interview/RequirementExtractor.ts, src/interview/RequirementExtractor.test.ts</files>
  <behavior>
    **Core behavior:**
    - Parse XML-tagged requirements from LLM response text
    - Extract: text, category, priority, confidence, area, source message ID
    - Handle multiple requirements in single response
    - Filter by confidence threshold (default 0.7)
    - Map interview categories to RequirementsDB categories

    **Test cases:**
    1. extract() with single requirement → returns array with one ExtractedRequirement
    2. extract() with multiple requirements → returns all parsed requirements
    3. extract() with no requirements → returns empty array
    4. extract() with malformed XML → skips invalid, returns valid ones
    5. extract() filters low confidence (below threshold)
    6. extract() maps categories correctly (non_functional → non-functional)
    7. extractTag() helper parses XML tags correctly
    8. extractTag() returns null for missing tags
    9. setConfidenceThreshold() changes filtering behavior
    10. Handles real-world LLM response with thinking tags + requirements
  </behavior>
  <implementation>
    **Types (src/interview/types.ts):**
    ```typescript
    export interface ExtractedRequirement {
      id: string;
      text: string;
      category: 'functional' | 'non-functional' | 'technical' | 'constraint' | 'assumption';
      priority: 'must' | 'should' | 'could' | 'wont';
      confidence: number;
      area?: string;
      sourceMessageId: string;
    }

    export interface ExtractionResult {
      requirements: ExtractedRequirement[];
      rawCount: number;
      filteredCount: number;
    }
    ```

    **RequirementExtractor class:**
    - Constructor takes optional confidenceThreshold (default 0.7)
    - extract(responseText: string, sourceMessageId: string): ExtractionResult
    - Uses regex to find all <requirement>...</requirement> blocks
    - Parses each block with extractTag() helper
    - Maps interview categories to DB categories
    - Filters by confidence threshold
    - Generates IDs with nanoid

    **Category mapping:**
    - functional → functional
    - non_functional → non-functional
    - technical → technical
    - constraint → constraint (new - may need to handle in DB)
    - assumption → assumption (new - may need to handle)
    - user_story → functional (with note)
  </implementation>
</feature>

<verification>
```bash
npm test -- src/interview/RequirementExtractor.test.ts
```
All 10 tests pass.
</verification>

<success_criteria>
- Failing tests written and committed (RED)
- Implementation passes all tests (GREEN)
- Refactor complete if needed
- All 2-3 commits present
- RequirementExtractor handles real LLM response format
</success_criteria>

<output>
After completion, create `.planning/phases/09-interview-engine/09-01-SUMMARY.md`:

# Plan 09-01: RequirementExtractor (TDD) Summary

**[One-liner: what shipped]**

## TDD Cycle

### RED
- What test was written
- Why it failed

### GREEN
- What implementation made it pass

### REFACTOR
- What cleanup was done (if any)

## Files Created/Modified

- `src/interview/types.ts` - Interview engine types
- `src/interview/RequirementExtractor.ts` - Extraction logic
- `src/interview/RequirementExtractor.test.ts` - 10 tests

## Commits

- test(09-01): add failing tests for RequirementExtractor
- feat(09-01): implement RequirementExtractor
- refactor(09-01): [if applicable]

## Next Step

Ready for 09-02-PLAN.md (QuestionGenerator + InterviewEngine)
</output>
