---
phase: 01-foundation
plan: 08
type: execute
depends_on: ["01-04"]
files_modified: [src/persistence/database/DatabaseClient.ts, src/persistence/database/schema.ts, src/persistence/database/migrations/0001_initial.ts, drizzle.config.ts, src/scripts/migrate.ts]
---

<objective>
Implement SQLite database foundation with Drizzle ORM.

Purpose: Create the persistence layer that stores projects, tasks, agents, and checkpoints - enabling session recovery and state management.
Output: Working DatabaseClient with schema, migrations, and basic CRUD operations.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md

**Reference specifications:**
- Master Book Section 4.2 BUILD-004: Database Foundation (12 hours)
- Libraries: better-sqlite3, drizzle-orm, drizzle-kit

**Key implementation notes from Master Book:**
- Use WAL mode for better-sqlite3 (better concurrency)
- Tables: projects, features, sub_features, tasks, agents, checkpoints, metrics, sessions, requirements
- Auto-run migrations on startup
- Target: 200-250 LOC for DatabaseClient, 150-200 LOC for schema

**Prior plan reference:**
@.planning/phases/01-foundation/01-04-SUMMARY.md (when available)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Drizzle schema</name>
  <files>src/persistence/database/schema.ts</files>
  <action>
Create complete Drizzle schema with all tables from Master Book:

```typescript
import { sqliteTable, text, integer, real, blob } from 'drizzle-orm/sqlite-core';
import { relations } from 'drizzle-orm';

// Projects table
export const projects = sqliteTable('projects', {
  id: text('id').primaryKey(),
  name: text('name').notNull(),
  description: text('description'),
  mode: text('mode').$type<'genesis' | 'evolution'>().notNull(),
  status: text('status').notNull(), // ProjectStatus
  rootPath: text('root_path').notNull(),
  repositoryUrl: text('repository_url'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull(),
  completedAt: integer('completed_at', { mode: 'timestamp' }),
});

// Features table
export const features = sqliteTable('features', {
  id: text('id').primaryKey(),
  projectId: text('project_id').notNull().references(() => projects.id, { onDelete: 'cascade' }),
  name: text('name').notNull(),
  description: text('description'),
  priority: text('priority').$type<'must' | 'should' | 'could' | 'wont'>().notNull().default('should'),
  status: text('status').notNull().default('backlog'),
  estimatedTasks: integer('estimated_tasks').default(0),
  completedTasks: integer('completed_tasks').default(0),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull(),
});

// Sub-features table
export const subFeatures = sqliteTable('sub_features', {
  id: text('id').primaryKey(),
  featureId: text('feature_id').notNull().references(() => features.id, { onDelete: 'cascade' }),
  name: text('name').notNull(),
  description: text('description'),
  status: text('status').notNull().default('backlog'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
});

// Tasks table
export const tasks = sqliteTable('tasks', {
  id: text('id').primaryKey(),
  projectId: text('project_id').notNull().references(() => projects.id, { onDelete: 'cascade' }),
  featureId: text('feature_id').references(() => features.id),
  subFeatureId: text('sub_feature_id').references(() => subFeatures.id),
  name: text('name').notNull(),
  description: text('description'),
  status: text('status').notNull().default('pending'),
  size: text('size').$type<'atomic' | 'small'>().notNull().default('small'),
  assignedAgent: text('assigned_agent'),
  worktreePath: text('worktree_path'),
  branchName: text('branch_name'),
  dependsOn: text('depends_on'), // JSON array of task IDs
  blockedBy: text('blocked_by'),
  qaIterations: integer('qa_iterations').default(0),
  maxIterations: integer('max_iterations').default(50),
  estimatedMinutes: integer('estimated_minutes').default(15),
  actualMinutes: integer('actual_minutes'),
  startedAt: integer('started_at', { mode: 'timestamp' }),
  completedAt: integer('completed_at', { mode: 'timestamp' }),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull(),
});

// Agents table
export const agents = sqliteTable('agents', {
  id: text('id').primaryKey(),
  type: text('type').$type<'planner' | 'coder' | 'tester' | 'reviewer' | 'merger'>().notNull(),
  status: text('status').notNull().default('idle'),
  currentTaskId: text('current_task_id'),
  worktreePath: text('worktree_path'),
  branchName: text('branch_name'),
  tokensUsed: integer('tokens_used').default(0),
  tasksCompleted: integer('tasks_completed').default(0),
  tasksFailed: integer('tasks_failed').default(0),
  spawnedAt: integer('spawned_at', { mode: 'timestamp' }).notNull(),
  lastActivityAt: integer('last_activity_at', { mode: 'timestamp' }).notNull(),
  terminatedAt: integer('terminated_at', { mode: 'timestamp' }),
  terminationReason: text('termination_reason'),
});

// Checkpoints table
export const checkpoints = sqliteTable('checkpoints', {
  id: text('id').primaryKey(),
  projectId: text('project_id').notNull().references(() => projects.id, { onDelete: 'cascade' }),
  name: text('name'),
  reason: text('reason'),
  state: text('state'), // JSON blob of full state
  gitCommit: text('git_commit'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
});

// Requirements table
export const requirements = sqliteTable('requirements', {
  id: text('id').primaryKey(),
  projectId: text('project_id').notNull().references(() => projects.id, { onDelete: 'cascade' }),
  category: text('category').notNull(),
  description: text('description').notNull(),
  priority: text('priority').notNull().default('medium'),
  source: text('source'),
  linkedFeatures: text('linked_features'), // JSON array
  validated: integer('validated', { mode: 'boolean' }).default(false),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
});

// Metrics table (for tracking)
export const metrics = sqliteTable('metrics', {
  id: text('id').primaryKey(),
  projectId: text('project_id').notNull().references(() => projects.id, { onDelete: 'cascade' }),
  agentId: text('agent_id'),
  taskId: text('task_id'),
  type: text('type').notNull(), // 'token_usage', 'task_duration', 'qa_iterations'
  value: real('value').notNull(),
  metadata: text('metadata'), // JSON
  timestamp: integer('timestamp', { mode: 'timestamp' }).notNull(),
});

// Sessions table (for interview/interaction history)
export const sessions = sqliteTable('sessions', {
  id: text('id').primaryKey(),
  projectId: text('project_id').notNull().references(() => projects.id, { onDelete: 'cascade' }),
  type: text('type').notNull(), // 'interview', 'planning', 'execution'
  status: text('status').notNull().default('active'),
  data: text('data'), // JSON blob
  startedAt: integer('started_at', { mode: 'timestamp' }).notNull(),
  endedAt: integer('ended_at', { mode: 'timestamp' }),
});

// Define relations for type-safe queries
export const projectsRelations = relations(projects, ({ many }) => ({
  features: many(features),
  tasks: many(tasks),
  checkpoints: many(checkpoints),
  requirements: many(requirements),
}));

export const featuresRelations = relations(features, ({ one, many }) => ({
  project: one(projects, { fields: [features.projectId], references: [projects.id] }),
  subFeatures: many(subFeatures),
  tasks: many(tasks),
}));

export const tasksRelations = relations(tasks, ({ one }) => ({
  project: one(projects, { fields: [tasks.projectId], references: [projects.id] }),
  feature: one(features, { fields: [tasks.featureId], references: [features.id] }),
}));
```

Use proper Drizzle types throughout. All timestamps use integer mode.
  </action>
  <verify>pnpm typecheck passes</verify>
  <done>schema.ts contains all 9 tables with relations defined</done>
</task>

<task type="auto">
  <name>Task 2: Implement DatabaseClient</name>
  <files>src/persistence/database/DatabaseClient.ts, drizzle.config.ts</files>
  <action>
Create DatabaseClient with better-sqlite3 and Drizzle:

```typescript
import Database from 'better-sqlite3';
import { drizzle, BetterSQLite3Database } from 'drizzle-orm/better-sqlite3';
import { migrate } from 'drizzle-orm/better-sqlite3/migrator';
import * as schema from './schema';
import { join } from 'pathe';

export interface DatabaseClientOptions {
  path: string;           // Database file path or ':memory:'
  migrationsDir?: string; // Path to migrations folder
  debug?: boolean;        // Log queries
}

export class DatabaseClient {
  private sqlite: Database.Database;
  private _db: BetterSQLite3Database<typeof schema>;

  private constructor(options: DatabaseClientOptions) {
    // Create SQLite connection with WAL mode
    this.sqlite = new Database(options.path);
    this.sqlite.pragma('journal_mode = WAL');
    this.sqlite.pragma('foreign_keys = ON');

    // Create Drizzle instance
    this._db = drizzle(this.sqlite, {
      schema,
      logger: options.debug,
    });
  }

  static async create(options: DatabaseClientOptions): Promise<DatabaseClient> {
    const client = new DatabaseClient(options);

    // Run migrations if directory provided
    if (options.migrationsDir) {
      await client.migrate(options.migrationsDir);
    }

    return client;
  }

  get db(): BetterSQLite3Database<typeof schema> {
    return this._db;
  }

  async migrate(migrationsDir: string): Promise<void> {
    migrate(this._db, { migrationsFolder: migrationsDir });
  }

  async tables(): Promise<string[]> {
    const result = this.sqlite
      .prepare("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' AND name NOT LIKE '_drizzle%'")
      .all() as { name: string }[];
    return result.map(r => r.name);
  }

  async close(): Promise<void> {
    this.sqlite.close();
  }

  // Transaction helper
  async transaction<T>(fn: (tx: typeof this._db) => Promise<T>): Promise<T> {
    return this._db.transaction(async (tx) => {
      return fn(tx as typeof this._db);
    });
  }

  // Health check
  async ping(): Promise<boolean> {
    try {
      this.sqlite.prepare('SELECT 1').get();
      return true;
    } catch {
      return false;
    }
  }
}
```

Create drizzle.config.ts:

```typescript
import type { Config } from 'drizzle-kit';

export default {
  schema: './src/persistence/database/schema.ts',
  out: './src/persistence/database/migrations',
  dialect: 'sqlite',
  dbCredentials: {
    url: process.env.DATABASE_PATH || './data/nexus.db',
  },
} satisfies Config;
```

Ensure WAL mode is set for better concurrent read/write performance.
  </action>
  <verify>pnpm typecheck passes</verify>
  <done>DatabaseClient class with WAL mode, migrations support, transaction helper, and drizzle.config.ts created</done>
</task>

<task type="auto">
  <name>Task 3: Create migration and migration script</name>
  <files>src/persistence/database/migrations/0001_initial.ts, src/scripts/migrate.ts</files>
  <action>
Create initial migration file (0001_initial.ts):

```typescript
import { sql } from 'drizzle-orm';
import type { BetterSQLite3Database } from 'drizzle-orm/better-sqlite3';

export async function up(db: BetterSQLite3Database): Promise<void> {
  // Projects
  db.run(sql`
    CREATE TABLE IF NOT EXISTS projects (
      id TEXT PRIMARY KEY,
      name TEXT NOT NULL,
      description TEXT,
      mode TEXT NOT NULL CHECK(mode IN ('genesis', 'evolution')),
      status TEXT NOT NULL,
      root_path TEXT NOT NULL,
      repository_url TEXT,
      created_at INTEGER NOT NULL,
      updated_at INTEGER NOT NULL,
      completed_at INTEGER
    )
  `);

  // Features
  db.run(sql`
    CREATE TABLE IF NOT EXISTS features (
      id TEXT PRIMARY KEY,
      project_id TEXT NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
      name TEXT NOT NULL,
      description TEXT,
      priority TEXT NOT NULL DEFAULT 'should',
      status TEXT NOT NULL DEFAULT 'backlog',
      estimated_tasks INTEGER DEFAULT 0,
      completed_tasks INTEGER DEFAULT 0,
      created_at INTEGER NOT NULL,
      updated_at INTEGER NOT NULL
    )
  `);

  // Sub-features
  db.run(sql`
    CREATE TABLE IF NOT EXISTS sub_features (
      id TEXT PRIMARY KEY,
      feature_id TEXT NOT NULL REFERENCES features(id) ON DELETE CASCADE,
      name TEXT NOT NULL,
      description TEXT,
      status TEXT NOT NULL DEFAULT 'backlog',
      created_at INTEGER NOT NULL
    )
  `);

  // Tasks
  db.run(sql`
    CREATE TABLE IF NOT EXISTS tasks (
      id TEXT PRIMARY KEY,
      project_id TEXT NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
      feature_id TEXT REFERENCES features(id),
      sub_feature_id TEXT REFERENCES sub_features(id),
      name TEXT NOT NULL,
      description TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      size TEXT NOT NULL DEFAULT 'small',
      assigned_agent TEXT,
      worktree_path TEXT,
      branch_name TEXT,
      depends_on TEXT,
      blocked_by TEXT,
      qa_iterations INTEGER DEFAULT 0,
      max_iterations INTEGER DEFAULT 50,
      estimated_minutes INTEGER DEFAULT 15,
      actual_minutes INTEGER,
      started_at INTEGER,
      completed_at INTEGER,
      created_at INTEGER NOT NULL,
      updated_at INTEGER NOT NULL
    )
  `);

  // Agents
  db.run(sql`
    CREATE TABLE IF NOT EXISTS agents (
      id TEXT PRIMARY KEY,
      type TEXT NOT NULL,
      status TEXT NOT NULL DEFAULT 'idle',
      current_task_id TEXT,
      worktree_path TEXT,
      branch_name TEXT,
      tokens_used INTEGER DEFAULT 0,
      tasks_completed INTEGER DEFAULT 0,
      tasks_failed INTEGER DEFAULT 0,
      spawned_at INTEGER NOT NULL,
      last_activity_at INTEGER NOT NULL,
      terminated_at INTEGER,
      termination_reason TEXT
    )
  `);

  // Checkpoints
  db.run(sql`
    CREATE TABLE IF NOT EXISTS checkpoints (
      id TEXT PRIMARY KEY,
      project_id TEXT NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
      name TEXT,
      reason TEXT,
      state TEXT,
      git_commit TEXT,
      created_at INTEGER NOT NULL
    )
  `);

  // Requirements
  db.run(sql`
    CREATE TABLE IF NOT EXISTS requirements (
      id TEXT PRIMARY KEY,
      project_id TEXT NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
      category TEXT NOT NULL,
      description TEXT NOT NULL,
      priority TEXT NOT NULL DEFAULT 'medium',
      source TEXT,
      linked_features TEXT,
      validated INTEGER DEFAULT 0,
      created_at INTEGER NOT NULL
    )
  `);

  // Metrics
  db.run(sql`
    CREATE TABLE IF NOT EXISTS metrics (
      id TEXT PRIMARY KEY,
      project_id TEXT NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
      agent_id TEXT,
      task_id TEXT,
      type TEXT NOT NULL,
      value REAL NOT NULL,
      metadata TEXT,
      timestamp INTEGER NOT NULL
    )
  `);

  // Sessions
  db.run(sql`
    CREATE TABLE IF NOT EXISTS sessions (
      id TEXT PRIMARY KEY,
      project_id TEXT NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
      type TEXT NOT NULL,
      status TEXT NOT NULL DEFAULT 'active',
      data TEXT,
      started_at INTEGER NOT NULL,
      ended_at INTEGER
    )
  `);

  // Create indexes
  db.run(sql`CREATE INDEX IF NOT EXISTS idx_features_project ON features(project_id)`);
  db.run(sql`CREATE INDEX IF NOT EXISTS idx_tasks_project ON tasks(project_id)`);
  db.run(sql`CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status)`);
  db.run(sql`CREATE INDEX IF NOT EXISTS idx_agents_status ON agents(status)`);
  db.run(sql`CREATE INDEX IF NOT EXISTS idx_checkpoints_project ON checkpoints(project_id)`);
}

export async function down(db: BetterSQLite3Database): Promise<void> {
  const tables = ['sessions', 'metrics', 'requirements', 'checkpoints', 'agents', 'tasks', 'sub_features', 'features', 'projects'];
  for (const table of tables) {
    db.run(sql`DROP TABLE IF EXISTS ${sql.identifier(table)}`);
  }
}
```

Create migrate script (src/scripts/migrate.ts):

```typescript
import { DatabaseClient } from '../persistence/database/DatabaseClient';
import { join } from 'pathe';

async function main() {
  const dbPath = process.env.DATABASE_PATH || './data/nexus.db';
  const migrationsDir = join(__dirname, '../persistence/database/migrations');

  console.log(`Running migrations on ${dbPath}...`);

  const client = await DatabaseClient.create({
    path: dbPath,
    migrationsDir,
  });

  const tables = await client.tables();
  console.log(`Database has ${tables.length} tables: ${tables.join(', ')}`);

  await client.close();
  console.log('Migrations complete.');
}

main().catch(console.error);
```

Note: For Drizzle Kit to work, use SQL-based migrations in the migrations folder. The file above is the conceptual migration - use `pnpm drizzle-kit generate` to create actual migration files.
  </action>
  <verify>pnpm db:migrate runs without error and creates tables</verify>
  <done>Migration system working, all 9 tables created with proper indexes</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm typecheck` passes
- [ ] `pnpm db:migrate` runs successfully
- [ ] Database file created with all tables
- [ ] WAL mode enabled (journal_mode = WAL)
- [ ] Foreign keys enabled
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Database foundation ready for higher-level persistence services
- Phase 1: Foundation complete
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-08-SUMMARY.md`

**Phase 1 complete** - Ready for Phase 2: Infrastructure (if roadmap still has that as separate phase) or proceed with STATE.md format, checkpoints, memory system.
</output>
