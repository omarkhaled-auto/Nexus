---
phase: 01-foundation
plan: 03
type: execute
depends_on: ["01-02"]
files_modified: [src/types/events.ts, src/types/api.ts, src/types/index.ts]
---

<objective>
Create event system and API type definitions.

Purpose: Define the 48+ event types for the EventBus and all API request/response interfaces - completing the type foundation.
Output: Complete events.ts with all event types, api.ts with API interfaces.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md

**Reference specifications:**
- Master Book Section 4.2 BUILD-002: Type Definitions
- Master Book Section 3.4: Core TypeScript Interfaces (events.ts ~150-200 LOC)
- Master Book Appendix C: Event Catalog (48+ event types)

**Prior plan reference:**
@.planning/phases/01-foundation/01-02-SUMMARY.md (when available)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create event types</name>
  <files>src/types/events.ts</files>
  <action>
Create src/types/events.ts with all 48+ event types from Master Book:

```typescript
import type { Project, Feature, Requirement, ProjectStatus, FeatureStatus, Priority } from './core';
import type { Task, TaskStatus, TaskResult, QAResult } from './task';
import type { Agent, AgentType, AgentStatus } from './agent';

// Base event structure
export interface NexusEvent<T = unknown> {
  id: string;
  type: EventType;
  timestamp: Date;
  payload: T;
  source: string; // Component that emitted
  correlationId?: string; // For tracing related events
}

// All event types
export type EventType =
  // Project lifecycle (8 events)
  | 'project:created'
  | 'project:updated'
  | 'project:status-changed'
  | 'project:completed'
  | 'project:failed'
  | 'project:paused'
  | 'project:resumed'
  | 'project:deleted'

  // Feature lifecycle (6 events)
  | 'feature:created'
  | 'feature:updated'
  | 'feature:status-changed'
  | 'feature:completed'
  | 'feature:failed'
  | 'feature:deleted'

  // Task lifecycle (10 events)
  | 'task:created'
  | 'task:queued'
  | 'task:assigned'
  | 'task:started'
  | 'task:progress'
  | 'task:qa-iteration'
  | 'task:completed'
  | 'task:failed'
  | 'task:blocked'
  | 'task:escalated'

  // Agent lifecycle (8 events)
  | 'agent:spawned'
  | 'agent:assigned'
  | 'agent:started'
  | 'agent:progress'
  | 'agent:idle'
  | 'agent:error'
  | 'agent:terminated'
  | 'agent:metrics-updated'

  // QA events (6 events)
  | 'qa:build-started'
  | 'qa:build-completed'
  | 'qa:lint-completed'
  | 'qa:test-completed'
  | 'qa:review-completed'
  | 'qa:loop-completed'

  // Interview events (6 events)
  | 'interview:started'
  | 'interview:question-asked'
  | 'interview:requirement-captured'
  | 'interview:category-completed'
  | 'interview:completed'
  | 'interview:cancelled'

  // System events (4 events)
  | 'system:checkpoint-created'
  | 'system:checkpoint-restored'
  | 'system:error'
  | 'system:warning';

// Event payload types
export interface ProjectCreatedPayload {
  project: Project;
}

export interface ProjectStatusChangedPayload {
  projectId: string;
  previousStatus: ProjectStatus;
  newStatus: ProjectStatus;
  reason?: string;
}

export interface FeatureCreatedPayload {
  feature: Feature;
  projectId: string;
}

export interface FeatureStatusChangedPayload {
  featureId: string;
  projectId: string;
  previousStatus: FeatureStatus;
  newStatus: FeatureStatus;
}

export interface TaskCreatedPayload {
  task: Task;
  projectId: string;
  featureId?: string;
}

export interface TaskAssignedPayload {
  taskId: string;
  agentId: string;
  agentType: AgentType;
  worktreePath: string;
}

export interface TaskProgressPayload {
  taskId: string;
  agentId: string;
  message: string;
  percentage?: number;
}

export interface TaskQAIterationPayload {
  taskId: string;
  iteration: number;
  result: QAResult;
}

export interface TaskCompletedPayload {
  taskId: string;
  result: TaskResult;
}

export interface TaskFailedPayload {
  taskId: string;
  error: string;
  iterations: number;
  escalated: boolean;
}

export interface AgentSpawnedPayload {
  agent: Agent;
}

export interface AgentAssignedPayload {
  agentId: string;
  taskId: string;
  worktreePath: string;
}

export interface AgentProgressPayload {
  agentId: string;
  taskId: string;
  action: string;
  details?: string;
}

export interface AgentErrorPayload {
  agentId: string;
  taskId?: string;
  error: string;
  recoverable: boolean;
}

export interface AgentTerminatedPayload {
  agentId: string;
  reason: 'completed' | 'error' | 'timeout' | 'manual';
  metrics: Agent['metrics'];
}

export interface QABuildCompletedPayload {
  taskId: string;
  passed: boolean;
  errors: string[];
  duration: number;
}

export interface QALoopCompletedPayload {
  taskId: string;
  passed: boolean;
  iterations: number;
  finalResult: QAResult;
}

export interface InterviewQuestionAskedPayload {
  projectId: string;
  questionId: string;
  question: string;
  category?: string;
}

export interface InterviewRequirementCapturedPayload {
  projectId: string;
  requirement: Requirement;
}

export interface CheckpointCreatedPayload {
  checkpointId: string;
  projectId: string;
  reason: string;
  gitCommit: string;
}

export interface SystemErrorPayload {
  component: string;
  error: string;
  stack?: string;
  recoverable: boolean;
}

// Event handler type
export type EventHandler<T = unknown> = (event: NexusEvent<T>) => void | Promise<void>;

// Type-safe event map
export interface EventPayloadMap {
  'project:created': ProjectCreatedPayload;
  'project:status-changed': ProjectStatusChangedPayload;
  'feature:created': FeatureCreatedPayload;
  'feature:status-changed': FeatureStatusChangedPayload;
  'task:created': TaskCreatedPayload;
  'task:assigned': TaskAssignedPayload;
  'task:progress': TaskProgressPayload;
  'task:qa-iteration': TaskQAIterationPayload;
  'task:completed': TaskCompletedPayload;
  'task:failed': TaskFailedPayload;
  'agent:spawned': AgentSpawnedPayload;
  'agent:assigned': AgentAssignedPayload;
  'agent:progress': AgentProgressPayload;
  'agent:error': AgentErrorPayload;
  'agent:terminated': AgentTerminatedPayload;
  'qa:build-completed': QABuildCompletedPayload;
  'qa:loop-completed': QALoopCompletedPayload;
  'interview:question-asked': InterviewQuestionAskedPayload;
  'interview:requirement-captured': InterviewRequirementCapturedPayload;
  'system:checkpoint-created': CheckpointCreatedPayload;
  'system:error': SystemErrorPayload;
  // Add remaining event types as needed with unknown payload
  [key: string]: unknown;
}
```

This defines the event-driven architecture foundation. Use strict types throughout.
  </action>
  <verify>pnpm typecheck passes</verify>
  <done>events.ts contains all 48 event types, NexusEvent interface, EventHandler type, and type-safe EventPayloadMap</done>
</task>

<task type="auto">
  <name>Task 2: Create API types and update index</name>
  <files>src/types/api.ts, src/types/index.ts</files>
  <action>
Create src/types/api.ts with API request/response interfaces:

```typescript
import type { Project, Feature, Requirement, Priority, RequirementCategory } from './core';
import type { Task, TaskStatus } from './task';
import type { Agent, AgentType } from './agent';

// Generic API response wrapper
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: ApiError;
  timestamp: Date;
}

export interface ApiError {
  code: string;
  message: string;
  details?: Record<string, unknown>;
}

// Pagination
export interface PaginationParams {
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

export interface PaginatedResponse<T> {
  items: T[];
  total: number;
  page: number;
  limit: number;
  hasMore: boolean;
}

// Project API
export interface CreateProjectRequest {
  name: string;
  description?: string;
  mode: 'genesis' | 'evolution';
  rootPath?: string;
  repositoryUrl?: string;
}

export interface UpdateProjectRequest {
  name?: string;
  description?: string;
}

export interface ProjectResponse extends Project {}

// Feature API
export interface CreateFeatureRequest {
  projectId: string;
  name: string;
  description?: string;
  priority?: Priority;
}

export interface UpdateFeatureRequest {
  name?: string;
  description?: string;
  priority?: Priority;
}

export interface FeatureResponse extends Feature {}

// Task API
export interface CreateTaskRequest {
  projectId: string;
  featureId?: string;
  name: string;
  description?: string;
  dependsOn?: string[];
  estimatedMinutes?: number;
}

export interface UpdateTaskRequest {
  name?: string;
  description?: string;
  status?: TaskStatus;
}

export interface TaskResponse extends Task {}

export interface TaskFilterParams extends PaginationParams {
  projectId?: string;
  featureId?: string;
  status?: TaskStatus | TaskStatus[];
  assignedAgent?: string;
}

// Agent API
export interface SpawnAgentRequest {
  type: AgentType;
  taskId?: string;
}

export interface AgentResponse extends Agent {}

export interface AgentFilterParams extends PaginationParams {
  type?: AgentType;
  status?: string;
}

// Interview API
export interface InterviewMessageRequest {
  projectId: string;
  message: string;
}

export interface InterviewMessageResponse {
  question?: string;
  captured?: Requirement[];
  isComplete: boolean;
  nextCategory?: string;
}

// Requirement API
export interface CreateRequirementRequest {
  projectId: string;
  category: RequirementCategory;
  description: string;
  priority?: Priority;
  source?: string;
}

export interface RequirementFilterParams extends PaginationParams {
  projectId?: string;
  category?: RequirementCategory;
  priority?: Priority;
  validated?: boolean;
}

// Checkpoint API
export interface CreateCheckpointRequest {
  projectId: string;
  reason?: string;
}

export interface CheckpointResponse {
  id: string;
  projectId: string;
  name?: string;
  gitCommit: string;
  createdAt: Date;
}

// Metrics API
export interface ProjectMetricsResponse {
  projectId: string;
  totalFeatures: number;
  completedFeatures: number;
  totalTasks: number;
  completedTasks: number;
  tasksInProgress: number;
  averageQAIterations: number;
  totalTokensUsed: number;
  estimatedCost: number;
  velocity: number; // tasks per hour
}

export interface AgentMetricsResponse {
  agentId: string;
  type: AgentType;
  tasksCompleted: number;
  tasksFailed: number;
  successRate: number;
  averageDuration: number;
  tokensUsed: number;
}

// WebSocket message types (for real-time updates)
export interface WSMessage<T = unknown> {
  type: 'event' | 'command' | 'response';
  payload: T;
  requestId?: string;
}

export interface WSEventMessage {
  type: 'event';
  eventType: string;
  payload: unknown;
}

export interface WSCommandMessage {
  type: 'command';
  command: string;
  params: Record<string, unknown>;
  requestId: string;
}
```

Update src/types/index.ts to include new exports:

```typescript
// Core types
export * from './core';

// Task types
export * from './task';

// Agent types
export * from './agent';

// Event types
export * from './events';

// API types
export * from './api';
```
  </action>
  <verify>pnpm typecheck passes</verify>
  <done>api.ts contains all API request/response types. index.ts updated to export events and api types.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm typecheck` passes with zero errors
- [ ] All 48 event types defined
- [ ] API types cover all CRUD operations
- [ ] index.ts exports all type modules
- [ ] No `any` types used
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Type definitions complete (BUILD-002 done)
- Ready for FileSystemService implementation (Plan 01-04)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
