---
phase: 02-persistence
plan: 03
type: tdd
depends_on: []
files_modified: [src/persistence/requirements/RequirementsDB.ts, src/persistence/requirements/RequirementsDB.test.ts]
---

<objective>
Implement RequirementsDB using TDD for requirements storage and categorization.

Purpose: Provide CRUD operations for project requirements captured during Genesis mode interviews, with categorization, search, and priority management.
Output: Working RequirementsDB service that stores, queries, and categorizes requirements.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.planning/phases/02-persistence/summary.md
./.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Database schema (requirements table already exists):
@src/persistence/database/schema.ts
@src/persistence/database/DatabaseClient.ts

# Reference implementations:
@src/infrastructure/file-system/FileSystemService.ts

**Tech stack available:** TypeScript 5.9+, Drizzle ORM, better-sqlite3, Vitest, zod
**Established patterns:**
- TDD red-green-refactor
- Error hierarchy with Object.setPrototypeOf
- Drizzle ORM for database operations

**Database table available:**
```typescript
requirements: {
  id, projectId, category, description, priority, source,
  userStories, acceptanceCriteria, linkedFeatures,
  validated, confidence, tags, createdAt
}
```

**Note:** The Master Book mentions JSON file storage, but we already have SQLite with the requirements table. This implementation will use the database as primary storage with optional JSON export for backup/portability.
</context>

<feature>
  <name>RequirementsDB</name>
  <files>src/persistence/requirements/RequirementsDB.ts, src/persistence/requirements/RequirementsDB.test.ts</files>
  <behavior>
**Master Book Reference:** BUILD-007 (Section 4.3)

## RequirementsDB

CRUD operations for project requirements with categorization and search.

**Core behaviors to test:**

1. **Custom Error Types:**
   - RequirementError base class
   - RequirementNotFoundError with requirementId
   - InvalidCategoryError with category and validCategories
   - DuplicateRequirementError with description (fuzzy match detected)

2. **Project Management:**
   - createProject(name: string, description?: string) returns projectId
   - getProject(projectId: string) returns project with requirement counts
   - listProjects() returns all projects with summaries
   - deleteProject(projectId: string) removes project and all requirements

3. **Requirement CRUD:**
   - addRequirement(projectId: string, input: RequirementInput) creates requirement
   - addRequirement generates unique id (nanoid)
   - addRequirement validates category against allowed values
   - addRequirement detects potential duplicates (fuzzy match on description)
   - getRequirement(reqId: string) returns Requirement or throws NotFound
   - updateRequirement(reqId: string, update: Partial<RequirementInput>) updates fields
   - deleteRequirement(reqId: string) removes requirement

4. **Categorization:**
   - Categories: 'functional', 'non-functional', 'ui-ux', 'technical', 'business-logic', 'integration'
   - categorizeRequirements(projectId: string) auto-categorizes uncategorized requirements
   - getCategoryStats(projectId: string) returns count per category
   - moveToCategory(reqId: string, category: Category) changes category

5. **Priority Management:**
   - Priorities: 'must', 'should', 'could', 'wont' (MoSCoW)
   - setPriority(reqId: string, priority: Priority) updates priority
   - getPriorityStats(projectId: string) returns count per priority
   - getByPriority(projectId: string, priority: Priority) returns filtered list

6. **Search and Filter:**
   - getRequirements(projectId: string, filters?: RequirementFilter) returns filtered list
   - Filter by: category, priority, validated, tags, search text
   - Search matches description, userStories, acceptanceCriteria
   - searchRequirements(projectId: string, query: string) full-text search

7. **Validation:**
   - validateRequirement(reqId: string) marks requirement as validated
   - invalidateRequirement(reqId: string) marks as not validated
   - getUnvalidated(projectId: string) returns requirements needing validation

8. **Linking:**
   - linkToFeature(reqId: string, featureId: string) adds feature link
   - unlinkFeature(reqId: string, featureId: string) removes feature link
   - getLinkedFeatures(reqId: string) returns linked feature IDs
   - getUnlinkedRequirements(projectId: string) returns requirements not linked to features

9. **Export/Import (JSON backup):**
   - exportToJSON(projectId: string) returns JSON string of all requirements
   - importFromJSON(projectId: string, json: string) imports requirements from JSON
   - Export format matches Master Book JSON structure

10. **Constructor:**
    - Accepts database client
    - Accepts optional logger

**RequirementInput Interface:**
```typescript
interface RequirementInput {
  category: RequirementCategory;
  description: string;
  priority?: RequirementPriority; // default: 'should'
  source?: string; // Interview question that led to this
  userStories?: string[];
  acceptanceCriteria?: string[];
  tags?: string[];
  confidence?: number; // 0-1, AI confidence in extraction
}

type RequirementCategory =
  | 'functional'
  | 'non-functional'
  | 'ui-ux'
  | 'technical'
  | 'business-logic'
  | 'integration';

type RequirementPriority = 'must' | 'should' | 'could' | 'wont';

interface RequirementFilter {
  category?: RequirementCategory;
  priority?: RequirementPriority;
  validated?: boolean;
  tags?: string[];
  search?: string;
  linkedToFeature?: string;
  unlinked?: boolean;
}
```

**Input/Output Examples:**

```typescript
// Create project
const projectId = await reqDb.createProject('My App', 'A task management app');

// Add requirement
const req = await reqDb.addRequirement(projectId, {
  category: 'functional',
  description: 'Users must be able to create tasks with title and due date',
  priority: 'must',
  source: 'User interview Q3',
  userStories: ['As a user, I want to create tasks so I can track my work'],
  acceptanceCriteria: ['Task has title field', 'Task has due date picker']
});

// Search requirements
const results = await reqDb.searchRequirements(projectId, 'authentication');

// Get by priority
const mustHaves = await reqDb.getByPriority(projectId, 'must');

// Export for backup
const json = await reqDb.exportToJSON(projectId);
```

**JSON Export Format (Master Book compatibility):**
```json
{
  "projectId": "proj-001",
  "projectName": "My App",
  "exportedAt": "2026-01-14T10:30:00Z",
  "requirements": [
    {
      "id": "req-001",
      "category": "functional",
      "description": "...",
      "priority": "must",
      "userStories": [],
      "acceptanceCriteria": [],
      "validated": true,
      "linkedFeatures": ["feat-001"]
    }
  ],
  "stats": {
    "total": 25,
    "byCategory": { "functional": 10, "non-functional": 5, ... },
    "byPriority": { "must": 8, "should": 10, ... }
  }
}
```
  </behavior>
  <implementation>
**RED Phase:**
Write failing tests for all operations. Start with error types, then CRUD, then categorization, then search/filter, then export/import.

**GREEN Phase:**

1. **CRUD Operations:**
   - Use Drizzle ORM for all database operations
   - Use nanoid for ID generation
   - Store userStories, acceptanceCriteria, linkedFeatures, tags as JSON strings

2. **Categorization:**
   - Simple keyword matching for auto-categorization:
     - 'functional': action verbs (create, update, delete, view)
     - 'non-functional': performance, security, scalability
     - 'ui-ux': design, layout, responsive, color
     - 'technical': api, database, integration
     - 'business-logic': calculate, validate, rule
     - 'integration': external, api, third-party

3. **Search:**
   - Use SQLite LIKE for text search
   - Search across description, userStories (JSON), acceptanceCriteria (JSON)

4. **Duplicate Detection:**
   - Levenshtein distance or simple word overlap percentage
   - Threshold: >80% similarity = potential duplicate

5. **Export/Import:**
   - JSON.stringify/parse for serialization
   - Validate structure on import with zod

**REFACTOR Phase:**
- Extract category keyword matching to configuration
- Consider adding full-text search index for large requirement sets
  </implementation>
</feature>

<verification>
- [ ] `pnpm test -- persistence/requirements` passes all tests
- [ ] `pnpm typecheck` passes
- [ ] `pnpm lint` passes
- [ ] Coverage >= 80% for RequirementsDB
- [ ] CRUD operations work correctly
- [ ] Search returns relevant results
- [ ] JSON export/import roundtrip is lossless
</verification>

<success_criteria>
- Failing tests written and committed (RED)
- Implementation passes all tests (GREEN)
- Refactor complete if needed
- All CRUD operations work
- Categorization and priority management work
- Search returns relevant results
- JSON export matches Master Book format
</success_criteria>

<output>
After completion, create `.planning/phases/02-persistence/02-03-SUMMARY.md` with:
- RED: What tests were written, why they failed
- GREEN: What implementation made them pass
- REFACTOR: What cleanup was done (if any)
- Commits: List of commits produced
</output>
