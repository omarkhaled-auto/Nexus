---
phase: 05-ui-foundation
plan: 04
type: execute
depends_on: ["05-03"]
files_modified: [src/main/ipc/handlers.ts, src/preload/index.ts, src/bridges/UIBackendBridge.ts, src/bridges/UIBackendBridge.test.ts]
---

<objective>
Implement IPC handlers and UIBackendBridge connecting React UI to NexusCoordinator orchestration layer.

Purpose: Enable the UI to communicate with the backend orchestration layer via secure IPC.
Output: Working IPC handlers, UIBackendBridge with event subscriptions, ~10 bridge tests.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-ui-foundation/05-RESEARCH.md
@.planning/phases/05-ui-foundation/05-CONTEXT.md
@.planning/phases/05-ui-foundation/05-03-SUMMARY.md
@src/orchestration/coordinator/NexusCoordinator.ts
@src/orchestration/events/EventBus.ts

**Tech stack:** Electron IPC, contextBridge, NexusCoordinator from Phase 4
**Key constraint:** Never expose raw ipcRenderer - only wrapped methods
**Security requirements:**
- Validate sender origin in main process
- contextIsolation: true (from 05-01)
- No event object passed to callbacks

**Orchestration layer available:**
- NexusCoordinator.getInstance() - singleton coordinator
- EventBus.getInstance() - event system
- AgentPool, TaskQueue - from Phase 4
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IPC handlers in main process</name>
  <files>src/main/ipc/handlers.ts, src/main/ipc/index.ts, src/main/main.ts</files>
  <action>
Create `src/main/ipc/handlers.ts`:
```typescript
import { ipcMain, IpcMainInvokeEvent, BrowserWindow } from 'electron'
import { NexusCoordinator } from '../../orchestration/coordinator/NexusCoordinator'
import { EventBus } from '../../orchestration/events/EventBus'
import type { Task } from '../../orchestration/types'

const ALLOWED_ORIGINS = ['http://localhost:5173', 'file://']

function validateSender(event: IpcMainInvokeEvent): boolean {
  const url = event.sender.getURL()
  return ALLOWED_ORIGINS.some(origin => url.startsWith(origin))
}

export function registerIpcHandlers() {
  const coordinator = NexusCoordinator.getInstance()
  const eventBus = EventBus.getInstance()

  // Mode operations
  ipcMain.handle('mode:genesis', async (event) => {
    if (!validateSender(event)) throw new Error('Unauthorized IPC sender')
    return coordinator.startGenesis()
  })

  ipcMain.handle('mode:evolution', async (event, projectId: string) => {
    if (!validateSender(event)) throw new Error('Unauthorized IPC sender')
    if (typeof projectId !== 'string' || !projectId) {
      throw new Error('Invalid projectId')
    }
    return coordinator.startEvolution(projectId)
  })

  // Project operations
  ipcMain.handle('project:get', async (event, id: string) => {
    if (!validateSender(event)) throw new Error('Unauthorized IPC sender')
    return coordinator.getProject(id)
  })

  ipcMain.handle('project:create', async (event, input: { name: string; mode: 'genesis' | 'evolution' }) => {
    if (!validateSender(event)) throw new Error('Unauthorized IPC sender')
    return coordinator.createProject(input)
  })

  // Task operations
  ipcMain.handle('tasks:list', async (event) => {
    if (!validateSender(event)) throw new Error('Unauthorized IPC sender')
    return coordinator.getTasks()
  })

  ipcMain.handle('task:update', async (event, id: string, update: Partial<Task>) => {
    if (!validateSender(event)) throw new Error('Unauthorized IPC sender')
    return coordinator.updateTask(id, update)
  })

  // Agent operations
  ipcMain.handle('agents:status', async (event) => {
    if (!validateSender(event)) throw new Error('Unauthorized IPC sender')
    return coordinator.getAgentStatus()
  })
}

export function setupEventForwarding(mainWindow: BrowserWindow) {
  const eventBus = EventBus.getInstance()

  // Forward backend events to renderer
  eventBus.on('task:updated', (task) => {
    mainWindow.webContents.send('task:updated', task)
  })

  eventBus.on('agent:status', (status) => {
    mainWindow.webContents.send('agent:status', status)
  })

  eventBus.on('execution:progress', (progress) => {
    mainWindow.webContents.send('execution:progress', progress)
  })
}
```

Create `src/main/ipc/index.ts` barrel:
```typescript
export { registerIpcHandlers, setupEventForwarding } from './handlers'
```

Update `src/main/main.ts` to call these:
```typescript
import { registerIpcHandlers, setupEventForwarding } from './ipc'

// In app.whenReady():
registerIpcHandlers()

// After createWindow():
if (mainWindow) {
  setupEventForwarding(mainWindow)
}
```

**Avoid:** Never trust input without validation. Always check sender origin.
  </action>
  <verify>
- No TypeScript errors: `npx tsc --noEmit`
- IPC handlers registered (check via console.log in dev)
  </verify>
  <done>IPC handlers created with validation, event forwarding set up</done>
</task>

<task type="auto">
  <name>Task 2: Update preload script with full nexusAPI</name>
  <files>src/preload/index.ts, src/preload/types.d.ts</files>
  <action>
Update `src/preload/index.ts` with complete API:
```typescript
import { contextBridge, ipcRenderer, IpcRendererEvent } from 'electron'

// Type-safe unsubscribe function
type Unsubscribe = () => void

const nexusAPI = {
  // Mode operations
  startGenesis: (): Promise<{ success: boolean; projectId?: string }> =>
    ipcRenderer.invoke('mode:genesis'),

  startEvolution: (projectId: string): Promise<{ success: boolean }> =>
    ipcRenderer.invoke('mode:evolution', projectId),

  // Project operations
  getProject: (id: string): Promise<unknown> =>
    ipcRenderer.invoke('project:get', id),

  createProject: (input: { name: string; mode: 'genesis' | 'evolution' }): Promise<{ id: string }> =>
    ipcRenderer.invoke('project:create', input),

  // Task operations
  getTasks: (): Promise<unknown[]> =>
    ipcRenderer.invoke('tasks:list'),

  updateTask: (id: string, update: Record<string, unknown>): Promise<void> =>
    ipcRenderer.invoke('task:update', id, update),

  // Agent operations
  getAgentStatus: (): Promise<unknown[]> =>
    ipcRenderer.invoke('agents:status'),

  // Event subscriptions - return unsubscribe functions
  onTaskUpdate: (callback: (task: unknown) => void): Unsubscribe => {
    const handler = (_event: IpcRendererEvent, task: unknown) => callback(task)
    ipcRenderer.on('task:updated', handler)
    return () => ipcRenderer.removeListener('task:updated', handler)
  },

  onAgentStatus: (callback: (status: unknown) => void): Unsubscribe => {
    const handler = (_event: IpcRendererEvent, status: unknown) => callback(status)
    ipcRenderer.on('agent:status', handler)
    return () => ipcRenderer.removeListener('agent:status', handler)
  },

  onExecutionProgress: (callback: (progress: unknown) => void): Unsubscribe => {
    const handler = (_event: IpcRendererEvent, progress: unknown) => callback(progress)
    ipcRenderer.on('execution:progress', handler)
    return () => ipcRenderer.removeListener('execution:progress', handler)
  },
}

contextBridge.exposeInMainWorld('nexusAPI', nexusAPI)

// TypeScript declaration for window.nexusAPI
export type NexusAPI = typeof nexusAPI
```

Create `src/preload/types.d.ts` for global type:
```typescript
import type { NexusAPI } from './index'

declare global {
  interface Window {
    nexusAPI: NexusAPI
  }
}

export {}
```

**Security notes:**
- Never pass `_event` to callbacks (contains ipcRenderer reference)
- Return unsubscribe functions to prevent memory leaks
- Use invoke (not send) for request-response patterns
  </action>
  <verify>
- DevTools console: `window.nexusAPI.startGenesis` is a function
- TypeScript recognizes `window.nexusAPI` type
  </verify>
  <done>Preload exposes complete nexusAPI with proper types</done>
</task>

<task type="auto">
  <name>Task 3: Create UIBackendBridge with tests</name>
  <files>src/bridges/UIBackendBridge.ts, src/bridges/UIBackendBridge.test.ts</files>
  <action>
Create `src/bridges/UIBackendBridge.ts`:
```typescript
import { useProjectStore } from '../renderer/src/stores/projectStore'
import { useTaskStore, type Task } from '../renderer/src/stores/taskStore'
import { useAgentStore, type AgentStatus } from '../renderer/src/stores/agentStore'
import { useUIStore } from '../renderer/src/stores/uiStore'

type Unsubscribe = () => void

/**
 * Bridge connecting UI Zustand stores to backend orchestration via IPC.
 * Singleton pattern - use getInstance().
 */
class UIBackendBridge {
  private static instance: UIBackendBridge
  private unsubscribers: Unsubscribe[] = []
  private initialized = false

  static getInstance(): UIBackendBridge {
    if (!UIBackendBridge.instance) {
      UIBackendBridge.instance = new UIBackendBridge()
    }
    return UIBackendBridge.instance
  }

  static resetInstance(): void {
    if (UIBackendBridge.instance) {
      UIBackendBridge.instance.cleanup()
    }
    UIBackendBridge.instance = undefined as unknown as UIBackendBridge
  }

  async initialize(): Promise<void> {
    if (this.initialized) return

    // Subscribe to backend events via IPC
    const unsubTask = window.nexusAPI.onTaskUpdate((task) => {
      useTaskStore.getState().updateTask((task as Task).id, task as Partial<Task>)
    })

    const unsubAgent = window.nexusAPI.onAgentStatus((status) => {
      useAgentStore.getState().setAgentStatus(status as AgentStatus)
    })

    const unsubProgress = window.nexusAPI.onExecutionProgress((progress) => {
      // Update UI store with progress
      console.log('Execution progress:', progress)
    })

    this.unsubscribers.push(unsubTask, unsubAgent, unsubProgress)
    this.initialized = true
  }

  async startGenesis(): Promise<void> {
    useUIStore.getState().setLoading(true)
    try {
      useProjectStore.getState().setMode('genesis')
      const result = await window.nexusAPI.startGenesis()
      if (!result.success) {
        throw new Error('Failed to start Genesis mode')
      }
    } catch (error) {
      useUIStore.getState().setError((error as Error).message)
      throw error
    } finally {
      useUIStore.getState().setLoading(false)
    }
  }

  async startEvolution(projectId: string): Promise<void> {
    useUIStore.getState().setLoading(true)
    try {
      useProjectStore.getState().setMode('evolution')
      const result = await window.nexusAPI.startEvolution(projectId)
      if (!result.success) {
        throw new Error('Failed to start Evolution mode')
      }
    } catch (error) {
      useUIStore.getState().setError((error as Error).message)
      throw error
    } finally {
      useUIStore.getState().setLoading(false)
    }
  }

  async loadTasks(): Promise<void> {
    const tasks = await window.nexusAPI.getTasks()
    useTaskStore.getState().setTasks(tasks as Task[])
  }

  async loadAgentStatus(): Promise<void> {
    const agents = await window.nexusAPI.getAgentStatus()
    for (const agent of agents as AgentStatus[]) {
      useAgentStore.getState().setAgentStatus(agent)
    }
  }

  isInitialized(): boolean {
    return this.initialized
  }

  cleanup(): void {
    this.unsubscribers.forEach(unsub => unsub())
    this.unsubscribers = []
    this.initialized = false
  }
}

export const uiBackendBridge = UIBackendBridge.getInstance()
export { UIBackendBridge }
```

Create `src/bridges/UIBackendBridge.test.ts`:
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { UIBackendBridge } from './UIBackendBridge'

// Mock window.nexusAPI
const mockNexusAPI = {
  startGenesis: vi.fn().mockResolvedValue({ success: true }),
  startEvolution: vi.fn().mockResolvedValue({ success: true }),
  getTasks: vi.fn().mockResolvedValue([]),
  getAgentStatus: vi.fn().mockResolvedValue([]),
  onTaskUpdate: vi.fn().mockReturnValue(() => {}),
  onAgentStatus: vi.fn().mockReturnValue(() => {}),
  onExecutionProgress: vi.fn().mockReturnValue(() => {}),
}

vi.stubGlobal('window', { nexusAPI: mockNexusAPI })

describe('UIBackendBridge', () => {
  beforeEach(() => {
    UIBackendBridge.resetInstance()
    vi.clearAllMocks()
  })

  describe('singleton', () => {
    it('should return same instance', () => {
      const a = UIBackendBridge.getInstance()
      const b = UIBackendBridge.getInstance()
      expect(a).toBe(b)
    })

    it('should create new instance after reset', () => {
      const a = UIBackendBridge.getInstance()
      UIBackendBridge.resetInstance()
      const b = UIBackendBridge.getInstance()
      expect(a).not.toBe(b)
    })
  })

  describe('initialize', () => {
    it('should subscribe to IPC events', async () => {
      const bridge = UIBackendBridge.getInstance()
      await bridge.initialize()
      expect(mockNexusAPI.onTaskUpdate).toHaveBeenCalled()
      expect(mockNexusAPI.onAgentStatus).toHaveBeenCalled()
    })

    it('should only initialize once', async () => {
      const bridge = UIBackendBridge.getInstance()
      await bridge.initialize()
      await bridge.initialize()
      expect(mockNexusAPI.onTaskUpdate).toHaveBeenCalledTimes(1)
    })
  })

  describe('startGenesis', () => {
    it('should call nexusAPI.startGenesis', async () => {
      const bridge = UIBackendBridge.getInstance()
      await bridge.startGenesis()
      expect(mockNexusAPI.startGenesis).toHaveBeenCalled()
    })
  })

  describe('startEvolution', () => {
    it('should call nexusAPI.startEvolution with projectId', async () => {
      const bridge = UIBackendBridge.getInstance()
      await bridge.startEvolution('project-123')
      expect(mockNexusAPI.startEvolution).toHaveBeenCalledWith('project-123')
    })
  })

  describe('cleanup', () => {
    it('should unsubscribe from events', async () => {
      const unsubMock = vi.fn()
      mockNexusAPI.onTaskUpdate.mockReturnValue(unsubMock)

      const bridge = UIBackendBridge.getInstance()
      await bridge.initialize()
      bridge.cleanup()

      expect(unsubMock).toHaveBeenCalled()
      expect(bridge.isInitialized()).toBe(false)
    })
  })
})
```

Update `src/bridges/index.ts` to include UIBackendBridge:
```typescript
export { AgentWorktreeBridge } from './AgentWorktreeBridge'
export { PlanningExecutionBridge } from './PlanningExecutionBridge'
export { UIBackendBridge, uiBackendBridge } from './UIBackendBridge'
```

**Avoid:** Don't call IPC methods directly from components - always go through bridge.
  </action>
  <verify>
- `pnpm test -- --testNamePattern "UIBackendBridge"` - all tests pass
- No TypeScript errors
  </verify>
  <done>UIBackendBridge implemented with ~10 tests passing</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] IPC handlers registered and validated
- [ ] nexusAPI exposed via contextBridge with proper types
- [ ] UIBackendBridge tests pass: `pnpm test -- --testNamePattern "UIBackendBridge"`
- [ ] No TypeScript errors: `npx tsc --noEmit`
- [ ] Security: sender validation in all handlers
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- IPC handlers secure with origin validation
- UIBackendBridge connects stores to backend
- Event subscriptions work with cleanup
  </success_criteria>

<output>
After completion, create `.planning/phases/05-ui-foundation/05-04-SUMMARY.md`:

# Phase 05-04: IPC + UIBackendBridge Summary

**[Substantive one-liner]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 05-05-PLAN.md (Routing + Mode Selector)
</output>
