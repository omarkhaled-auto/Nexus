---
phase: 05-ui-foundation
plan: 03
type: tdd
depends_on: ["05-02"]
files_modified: [src/renderer/src/stores/projectStore.ts, src/renderer/src/stores/taskStore.ts, src/renderer/src/stores/agentStore.ts, src/renderer/src/stores/uiStore.ts, src/renderer/src/stores/*.test.ts]
---

<objective>
Implement Zustand stores with TDD for project, task, agent, and UI state management.

Purpose: Create type-safe, tested state management that connects UI to backend data.
Output: 4 Zustand stores with ~32 tests following TDD discipline.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
./.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-ui-foundation/05-RESEARCH.md
@.planning/phases/05-ui-foundation/05-CONTEXT.md
@.planning/phases/05-ui-foundation/05-02-SUMMARY.md

**Tech stack:** Zustand v5, TypeScript strict mode
**Test expectation:** ~32 tests (8 projectStore, 8 taskStore, 6 agentStore, 10 uiStore)
**Key patterns:**
- Use `create<State>()` with TypeScript interfaces
- persist middleware for some stores
- No SSR concerns (Electron-only)

**Types from orchestration layer:**
- Task, TaskStatus from @/orchestration/types
- Agent status patterns from AgentPool
</context>

<tasks>

<task type="auto">
  <name>RED: Write failing tests for all 4 Zustand stores</name>
  <files>src/renderer/src/stores/projectStore.test.ts, src/renderer/src/stores/taskStore.test.ts, src/renderer/src/stores/agentStore.test.ts, src/renderer/src/stores/uiStore.test.ts</files>
  <action>
Install Zustand:
```bash
pnpm add zustand
```

Create test files with failing tests. Tests should describe the expected behavior before implementation.

**projectStore.test.ts** (~8 tests):
```typescript
import { describe, it, expect, beforeEach } from 'vitest'
import { useProjectStore } from './projectStore'

describe('projectStore', () => {
  beforeEach(() => {
    useProjectStore.getState().reset()
  })

  describe('mode management', () => {
    it('should initialize with null mode', () => {
      expect(useProjectStore.getState().mode).toBeNull()
    })

    it('should set mode to genesis', () => {
      useProjectStore.getState().setMode('genesis')
      expect(useProjectStore.getState().mode).toBe('genesis')
    })

    it('should set mode to evolution', () => {
      useProjectStore.getState().setMode('evolution')
      expect(useProjectStore.getState().mode).toBe('evolution')
    })
  })

  describe('project management', () => {
    it('should initialize with null currentProject', () => {
      expect(useProjectStore.getState().currentProject).toBeNull()
    })

    it('should set current project', () => {
      const project = { id: 'p1', name: 'Test', mode: 'genesis' as const, createdAt: new Date().toISOString() }
      useProjectStore.getState().setProject(project)
      expect(useProjectStore.getState().currentProject).toEqual(project)
    })

    it('should add project to list', () => {
      const project = { id: 'p1', name: 'Test', mode: 'genesis' as const, createdAt: new Date().toISOString() }
      useProjectStore.getState().addProject(project)
      expect(useProjectStore.getState().projects).toContainEqual(project)
    })

    it('should clear project and mode', () => {
      useProjectStore.getState().setMode('genesis')
      useProjectStore.getState().setProject({ id: 'p1', name: 'Test', mode: 'genesis', createdAt: '' })
      useProjectStore.getState().clearProject()
      expect(useProjectStore.getState().currentProject).toBeNull()
      expect(useProjectStore.getState().mode).toBeNull()
    })

    it('should reset to initial state', () => {
      useProjectStore.getState().setMode('genesis')
      useProjectStore.getState().reset()
      expect(useProjectStore.getState().mode).toBeNull()
      expect(useProjectStore.getState().projects).toEqual([])
    })
  })
})
```

**taskStore.test.ts** (~8 tests):
```typescript
describe('taskStore', () => {
  // Initial state
  it('should initialize with empty tasks array')
  it('should initialize with null selectedTaskId')

  // Task operations
  it('should set tasks array')
  it('should add single task')
  it('should update task by id')
  it('should remove task by id')
  it('should select task')
  it('should get task by id')
})
```

**agentStore.test.ts** (~6 tests):
```typescript
describe('agentStore', () => {
  // Agent status
  it('should initialize with empty agents map')
  it('should set agent status')
  it('should update single agent')
  it('should remove agent')
  it('should get active agents count')
  it('should clear all agents')
})
```

**uiStore.test.ts** (~10 tests):
```typescript
describe('uiStore', () => {
  // Sidebar state
  it('should initialize with sidebar open')
  it('should toggle sidebar')
  it('should set sidebar explicitly')

  // Loading states
  it('should initialize with loading false')
  it('should set loading state')

  // Error handling
  it('should initialize with no error')
  it('should set error message')
  it('should clear error')

  // Toast/notifications
  it('should add toast notification')
  it('should remove toast by id')
})
```

Create stub store files that export empty stores to make imports work (tests will fail on assertions).

**Avoid:** Don't implement the stores yet - just the tests and minimal stubs.
  </action>
  <verify>
- `pnpm test -- --testNamePattern "Store"` runs all tests
- All ~32 tests FAIL (this is expected in RED phase)
  </verify>
  <done>32 failing tests written, store interfaces defined</done>
</task>

<task type="auto">
  <name>GREEN: Implement all 4 Zustand stores to pass tests</name>
  <files>src/renderer/src/stores/projectStore.ts, src/renderer/src/stores/taskStore.ts, src/renderer/src/stores/agentStore.ts, src/renderer/src/stores/uiStore.ts, src/renderer/src/stores/index.ts</files>
  <action>
Implement each store to pass its tests:

**projectStore.ts:**
```typescript
import { create } from 'zustand'
import { persist, createJSONStorage } from 'zustand/middleware'

export interface Project {
  id: string
  name: string
  mode: 'genesis' | 'evolution'
  createdAt: string
}

interface ProjectState {
  currentProject: Project | null
  projects: Project[]
  mode: 'genesis' | 'evolution' | null

  setProject: (project: Project) => void
  setMode: (mode: 'genesis' | 'evolution') => void
  addProject: (project: Project) => void
  clearProject: () => void
  reset: () => void
}

const initialState = {
  currentProject: null,
  projects: [],
  mode: null,
}

export const useProjectStore = create<ProjectState>()(
  persist(
    (set) => ({
      ...initialState,
      setProject: (project) => set({ currentProject: project }),
      setMode: (mode) => set({ mode }),
      addProject: (project) => set((state) => ({ projects: [...state.projects, project] })),
      clearProject: () => set({ currentProject: null, mode: null }),
      reset: () => set(initialState),
    }),
    {
      name: 'nexus-project-store',
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({ projects: state.projects }),
    }
  )
)
```

**taskStore.ts:**
```typescript
import { create } from 'zustand'

export interface Task {
  id: string
  name: string
  status: 'pending' | 'in_progress' | 'completed' | 'failed'
  assignedAgent?: string
  estimatedMinutes?: number
}

interface TaskState {
  tasks: Task[]
  selectedTaskId: string | null

  setTasks: (tasks: Task[]) => void
  addTask: (task: Task) => void
  updateTask: (id: string, update: Partial<Task>) => void
  removeTask: (id: string) => void
  selectTask: (id: string | null) => void
  getTask: (id: string) => Task | undefined
  reset: () => void
}

export const useTaskStore = create<TaskState>((set, get) => ({
  tasks: [],
  selectedTaskId: null,

  setTasks: (tasks) => set({ tasks }),
  addTask: (task) => set((state) => ({ tasks: [...state.tasks, task] })),
  updateTask: (id, update) => set((state) => ({
    tasks: state.tasks.map((t) => (t.id === id ? { ...t, ...update } : t)),
  })),
  removeTask: (id) => set((state) => ({
    tasks: state.tasks.filter((t) => t.id !== id),
  })),
  selectTask: (id) => set({ selectedTaskId: id }),
  getTask: (id) => get().tasks.find((t) => t.id === id),
  reset: () => set({ tasks: [], selectedTaskId: null }),
}))
```

**agentStore.ts:**
```typescript
import { create } from 'zustand'

export interface AgentStatus {
  id: string
  type: 'coder' | 'tester' | 'reviewer' | 'merger'
  status: 'idle' | 'working' | 'error'
  currentTaskId?: string
}

interface AgentState {
  agents: Map<string, AgentStatus>

  setAgentStatus: (status: AgentStatus) => void
  updateAgent: (id: string, update: Partial<AgentStatus>) => void
  removeAgent: (id: string) => void
  getActiveCount: () => number
  clearAgents: () => void
  reset: () => void
}

export const useAgentStore = create<AgentState>((set, get) => ({
  agents: new Map(),

  setAgentStatus: (status) => set((state) => {
    const newAgents = new Map(state.agents)
    newAgents.set(status.id, status)
    return { agents: newAgents }
  }),
  updateAgent: (id, update) => set((state) => {
    const newAgents = new Map(state.agents)
    const existing = newAgents.get(id)
    if (existing) {
      newAgents.set(id, { ...existing, ...update })
    }
    return { agents: newAgents }
  }),
  removeAgent: (id) => set((state) => {
    const newAgents = new Map(state.agents)
    newAgents.delete(id)
    return { agents: newAgents }
  }),
  getActiveCount: () => {
    let count = 0
    get().agents.forEach((a) => { if (a.status === 'working') count++ })
    return count
  },
  clearAgents: () => set({ agents: new Map() }),
  reset: () => set({ agents: new Map() }),
}))
```

**uiStore.ts:**
```typescript
import { create } from 'zustand'

export interface Toast {
  id: string
  message: string
  type: 'info' | 'success' | 'error'
}

interface UIState {
  sidebarOpen: boolean
  isLoading: boolean
  error: string | null
  toasts: Toast[]

  toggleSidebar: () => void
  setSidebar: (open: boolean) => void
  setLoading: (loading: boolean) => void
  setError: (error: string | null) => void
  clearError: () => void
  addToast: (toast: Toast) => void
  removeToast: (id: string) => void
  reset: () => void
}

export const useUIStore = create<UIState>((set) => ({
  sidebarOpen: true,
  isLoading: false,
  error: null,
  toasts: [],

  toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),
  setSidebar: (open) => set({ sidebarOpen: open }),
  setLoading: (loading) => set({ isLoading: loading }),
  setError: (error) => set({ error }),
  clearError: () => set({ error: null }),
  addToast: (toast) => set((state) => ({ toasts: [...state.toasts, toast] })),
  removeToast: (id) => set((state) => ({
    toasts: state.toasts.filter((t) => t.id !== id),
  })),
  reset: () => set({ sidebarOpen: true, isLoading: false, error: null, toasts: [] }),
}))
```

Create `src/renderer/src/stores/index.ts` barrel export:
```typescript
export { useProjectStore, type Project } from './projectStore'
export { useTaskStore, type Task } from './taskStore'
export { useAgentStore, type AgentStatus } from './agentStore'
export { useUIStore, type Toast } from './uiStore'
```

**Avoid:** Don't add extra features not covered by tests. Minimal implementation only.
  </action>
  <verify>
- `pnpm test -- --testNamePattern "Store"` - ALL tests pass
- No TypeScript errors
  </verify>
  <done>All 32 tests pass, stores implemented</done>
</task>

<task type="auto">
  <name>REFACTOR: Clean up store implementations if needed</name>
  <files>src/renderer/src/stores/*.ts</files>
  <action>
Review implementations for:
1. Consistent naming conventions
2. Proper TypeScript types (no `any`)
3. Selector helpers for common patterns
4. Documentation comments for complex logic

Add selector helpers if beneficial:
```typescript
// projectStore.ts
export const useCurrentProject = () => useProjectStore((s) => s.currentProject)
export const useMode = () => useProjectStore((s) => s.mode)

// taskStore.ts
export const useSelectedTask = () => {
  const tasks = useTaskStore((s) => s.tasks)
  const selectedId = useTaskStore((s) => s.selectedTaskId)
  return tasks.find((t) => t.id === selectedId)
}

// agentStore.ts
export const useActiveAgents = () => {
  const agents = useAgentStore((s) => s.agents)
  return Array.from(agents.values()).filter((a) => a.status === 'working')
}
```

Run tests again to ensure no regressions.

**Avoid:** Don't add new features during refactor - only clean up existing code.
  </action>
  <verify>
- `pnpm test -- --testNamePattern "Store"` - ALL tests still pass
- Code is cleaner and better typed
  </verify>
  <done>Stores refactored, tests still passing, selectors added</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All ~32 store tests pass
- [ ] No TypeScript errors: `npx tsc --noEmit`
- [ ] All 4 stores export from barrel file
- [ ] Stores are type-safe with proper interfaces
</verification>

<success_criteria>

- Failing test written and committed (RED)
- Implementation passes tests (GREEN)
- Refactor complete (REFACTOR)
- All 2-3 commits present
- ~32 tests passing
  </success_criteria>

<output>
After completion, create `.planning/phases/05-ui-foundation/05-03-SUMMARY.md`:

# Phase 05-03: Zustand Stores (TDD) Summary

**[Substantive one-liner]**

## TDD Metrics

| Store | Tests | Status |
|-------|-------|--------|
| projectStore | 8 | PASS |
| taskStore | 8 | PASS |
| agentStore | 6 | PASS |
| uiStore | 10 | PASS |
| **Total** | **32** | **ALL PASS** |

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created

- `src/renderer/src/stores/projectStore.ts` - Project and mode state
- `src/renderer/src/stores/taskStore.ts` - Task list state
- `src/renderer/src/stores/agentStore.ts` - Agent status state
- `src/renderer/src/stores/uiStore.ts` - UI state (sidebar, loading, toasts)

## Commit History

| Hash | Type | Description |
|------|------|-------------|
| ... | test | Add failing tests for 4 Zustand stores (RED) |
| ... | feat | Implement Zustand stores (GREEN) |
| ... | refactor | Add selectors, clean up types |

## Next Step

Ready for 05-04-PLAN.md (IPC + UIBackendBridge)
</output>
