---
phase: 12-polish
plan: 01
type: execute
depends_on: []
files_modified: [src/main/services/settingsService.ts, src/main/ipc/settingsHandlers.ts, src/preload/index.ts, src/shared/types/settings.ts]
---

<objective>
Create settings backend with secure API key storage using safeStorage and electron-store.

Purpose: Establish the main process infrastructure for persisting settings securely. API keys encrypted via OS-level crypto (Keychain/DPAPI), non-sensitive settings in JSON.
Output: SettingsService with secure storage, IPC handlers exposed to renderer, TypeScript types.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-polish/12-CONTEXT.md
@.planning/phases/12-polish/12-RESEARCH.md

**Relevant source files:**
@src/main/index.ts
@src/preload/index.ts
@src/shared/types/index.ts

**From RESEARCH.md:**
- Use `safeStorage` for API keys (built-in Electron, OS-level crypto)
- Use `electron-store` for non-sensitive settings (JSON with schema validation)
- IPC bridge pattern: renderer → IPC → main → electron-store

**Installation required:**
```bash
pnpm add electron-store
```

**Anti-patterns from RESEARCH.md:**
- DON'T store API keys in plain text electron-store — use safeStorage
- DON'T store API keys in localStorage — renderer has no secure storage
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install electron-store and create settings types</name>
  <files>package.json, src/shared/types/settings.ts</files>
  <action>
1. Run `pnpm add electron-store`
2. Create src/shared/types/settings.ts with NexusSettings interface:

```typescript
export interface LLMSettings {
  claudeApiKeyEncrypted?: string
  geminiApiKeyEncrypted?: string
  openaiApiKeyEncrypted?: string
  defaultProvider: 'claude' | 'gemini' | 'openai'
  defaultModel: string
  fallbackEnabled: boolean
  fallbackOrder: string[]
}

export interface AgentSettings {
  maxParallelAgents: number
  taskTimeoutMinutes: number
  maxRetries: number
  autoRetryEnabled: boolean
}

export interface CheckpointSettings {
  autoCheckpointEnabled: boolean
  autoCheckpointIntervalMinutes: number
  maxCheckpointsToKeep: number
  checkpointOnFeatureComplete: boolean
}

export interface UISettings {
  theme: 'light' | 'dark' | 'system'
  sidebarWidth: number
  showNotifications: boolean
  notificationDuration: number
}

export interface ProjectSettings {
  defaultLanguage: string
  defaultTestFramework: string
  outputDirectory: string
}

export interface NexusSettings {
  llm: LLMSettings
  agents: AgentSettings
  checkpoints: CheckpointSettings
  ui: UISettings
  project: ProjectSettings
}

// Public view (no encrypted keys visible)
export interface NexusSettingsPublic {
  llm: Omit<LLMSettings, 'claudeApiKeyEncrypted' | 'geminiApiKeyEncrypted' | 'openaiApiKeyEncrypted'> & {
    hasClaudeKey: boolean
    hasGeminiKey: boolean
    hasOpenaiKey: boolean
  }
  agents: AgentSettings
  checkpoints: CheckpointSettings
  ui: UISettings
  project: ProjectSettings
}
```

3. Export from src/shared/types/index.ts
  </action>
  <verify>tsc --noEmit passes, types exported correctly</verify>
  <done>NexusSettings and related types defined, electron-store installed</done>
</task>

<task type="auto">
  <name>Task 2: Create SettingsService with safeStorage</name>
  <files>src/main/services/settingsService.ts</files>
  <action>
Create src/main/services/settingsService.ts:

1. Import electron-store and safeStorage from 'electron'
2. Define schema for electron-store with defaults:
   - defaultProvider: 'claude'
   - maxParallelAgents: 4
   - theme: 'system'
   - etc.

3. Implement SettingsService class:
   - `getAll(): NexusSettingsPublic` — returns settings with hasXxxKey flags instead of encrypted values
   - `get(key: string): unknown` — get single setting by dot-notation path
   - `set(key: string, value: unknown): void` — set single setting
   - `setApiKey(provider: 'claude' | 'gemini' | 'openai', plainKey: string): boolean` — encrypt with safeStorage, store as base64
   - `getApiKey(provider: string): string | null` — decrypt from base64
   - `hasApiKey(provider: string): boolean` — check if key exists
   - `clearApiKey(provider: string): void` — remove key
   - `reset(): void` — clear all settings to defaults

4. Use safeStorage pattern from RESEARCH.md:
```typescript
setApiKey(provider: string, plainKey: string): boolean {
  if (!safeStorage.isEncryptionAvailable()) {
    console.error('Encryption not available')
    return false
  }
  const encrypted = safeStorage.encryptString(plainKey)
  this.store.set(`llm.${provider}ApiKeyEncrypted`, encrypted.toString('base64'))
  return true
}
```

5. Export singleton instance
  </action>
  <verify>TypeScript compiles, no type errors</verify>
  <done>SettingsService encrypts API keys with safeStorage, persists to electron-store</done>
</task>

<task type="auto">
  <name>Task 3: Create IPC handlers and expose to renderer</name>
  <files>src/main/ipc/settingsHandlers.ts, src/preload/index.ts, src/main/index.ts</files>
  <action>
1. Create src/main/ipc/settingsHandlers.ts:

```typescript
import { ipcMain } from 'electron'
import { settingsService } from '../services/settingsService'

export function registerSettingsHandlers(): void {
  ipcMain.handle('settings:getAll', () => settingsService.getAll())
  ipcMain.handle('settings:get', (_, key: string) => settingsService.get(key))
  ipcMain.handle('settings:set', (_, key: string, value: unknown) => {
    settingsService.set(key, value)
    return true
  })
  ipcMain.handle('settings:setApiKey', (_, provider: string, key: string) =>
    settingsService.setApiKey(provider, key)
  )
  ipcMain.handle('settings:hasApiKey', (_, provider: string) =>
    settingsService.hasApiKey(provider)
  )
  ipcMain.handle('settings:clearApiKey', (_, provider: string) => {
    settingsService.clearApiKey(provider)
    return true
  })
  ipcMain.handle('settings:reset', () => {
    settingsService.reset()
    return true
  })
}
```

2. Call registerSettingsHandlers() in src/main/index.ts after app.whenReady()

3. Update src/preload/index.ts to expose settings API:
```typescript
settings: {
  getAll: () => ipcRenderer.invoke('settings:getAll'),
  get: (key: string) => ipcRenderer.invoke('settings:get', key),
  set: (key: string, value: unknown) => ipcRenderer.invoke('settings:set', key, value),
  setApiKey: (provider: string, key: string) => ipcRenderer.invoke('settings:setApiKey', provider, key),
  hasApiKey: (provider: string) => ipcRenderer.invoke('settings:hasApiKey', provider),
  clearApiKey: (provider: string) => ipcRenderer.invoke('settings:clearApiKey', provider),
  reset: () => ipcRenderer.invoke('settings:reset')
}
```

4. Add TypeScript types for window.api.settings in preload types
  </action>
  <verify>npm run build:electron succeeds, IPC handlers registered</verify>
  <done>Settings API exposed via window.api.settings, all methods accessible from renderer</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm run build:electron` succeeds
- [ ] `pnpm run typecheck` passes
- [ ] electron-store installed in dependencies
- [ ] Settings types exported from shared/types
- [ ] SettingsService uses safeStorage for API keys
- [ ] IPC handlers registered in main process
- [ ] window.api.settings exposed in preload
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- API keys encrypted with safeStorage (not plain text)
- Settings persist to electron-store JSON file
- IPC bridge connects renderer to main process settings
</success_criteria>

<output>
After completion, create `.planning/phases/12-polish/12-01-SUMMARY.md`
</output>
