---
phase: 12-polish
plan: 05
type: execute
depends_on: ["12-01", "12-02", "12-03", "12-04"]
files_modified: [README.md, src/renderer/src/stores/settingsStore.test.ts, src/renderer/src/hooks/useKeyboardShortcuts.test.ts]
---

<objective>
Create documentation, add tests for new components, and verify production build.

Purpose: Ensure the app is documented for users and passes all quality gates for release.
Output: Updated README with quick start, tests for settings and shortcuts, verified package build.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-polish/12-CONTEXT.md
@.planning/phases/12-polish/12-01-SUMMARY.md
@.planning/phases/12-polish/12-02-SUMMARY.md
@.planning/phases/12-polish/12-03-SUMMARY.md
@.planning/phases/12-polish/12-04-SUMMARY.md

**Relevant source files:**
@README.md
@electron-builder.yml

**From CONTEXT.md:**
- README with installation + quick start
- All existing tests still pass (1,400+)
- App builds and packages successfully
- Production build works end-to-end

**Test targets:** ~30-40 new tests total for Phase 12
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update README with installation and quick start</name>
  <files>README.md</files>
  <action>
Update README.md with user-focused documentation:

```markdown
# Nexus

> Transform ideas into production-quality applications using natural language

Nexus is an AI-powered desktop application that builds software autonomously. Describe what you want, and Nexus orchestrates multiple AI agents to plan, code, test, and review your application.

## Features

- **Genesis Mode**: Start with an idea. Nexus interviews you to understand requirements, then builds your application from scratch.
- **Evolution Mode**: Import an existing codebase. Add features via a Kanban board with drag-and-drop prioritization.
- **Multi-Agent Orchestration**: Coder, Tester, Reviewer, and Merger agents work in parallel with QA loops.
- **Human Checkpoints**: Review and approve at key milestones. You're always in control.
- **Real-time Dashboard**: Monitor agent activity, task progress, and cost tracking.

## Quick Start

### Prerequisites

- Node.js 20+
- pnpm 9+
- API keys for Claude (Anthropic) or Gemini (Google)

### Installation

```bash
# Clone the repository
git clone https://github.com/yourusername/nexus.git
cd nexus

# Install dependencies
pnpm install

# Start in development mode
pnpm dev:electron
```

### First Run

1. Launch Nexus
2. Open Settings (Cmd/Ctrl + ,)
3. Enter your API key in the LLM tab
4. Choose Genesis Mode to start a new project, or Evolution Mode to work on existing code

## Keyboard Shortcuts

| Shortcut | Action |
|----------|--------|
| Cmd/Ctrl + N | New project |
| Cmd/Ctrl + S | Create checkpoint |
| Cmd/Ctrl + , | Open settings |
| Cmd/Ctrl + K | Command palette |
| ? | Show all shortcuts |
| Esc | Close modal |

## Configuration

Settings are stored locally and encrypted. API keys use OS-level secure storage (Keychain on macOS, DPAPI on Windows).

### Settings Categories

- **LLM Providers**: API keys, default model, fallback order
- **Agent Behavior**: Max parallel agents, timeouts, retries
- **Checkpoints**: Auto-checkpoint interval, retention
- **UI Preferences**: Theme (light/dark/system), notifications
- **Project Defaults**: Language, test framework, output directory

## Building for Production

```bash
# Build the application
pnpm build:electron

# Package for distribution
pnpm package
```

Installers are created in the `dist/` directory.

## Development

```bash
# Run tests
pnpm test

# Run with coverage
pnpm test:coverage

# Type check
pnpm typecheck

# Lint
pnpm lint
```

## Architecture

Nexus uses a multi-process Electron architecture:

- **Main Process**: Orchestration, LLM clients, file system, settings (electron-store + safeStorage)
- **Renderer Process**: React UI with Zustand state management
- **Preload**: Secure IPC bridge between main and renderer

## License

MIT

## Contributing

See CONTRIBUTING.md for development guidelines.
```
  </action>
  <verify>README renders correctly, all links work</verify>
  <done>README updated with installation, quick start, features, and keyboard shortcuts</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for settings and keyboard shortcuts</name>
  <files>src/renderer/src/stores/settingsStore.test.ts, src/renderer/src/hooks/useKeyboardShortcuts.test.ts, src/renderer/src/components/ErrorBoundary.test.tsx</files>
  <action>
1. Create src/renderer/src/stores/settingsStore.test.ts:
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { useSettingsStore } from './settingsStore'

// Mock window.api
vi.mock('electron', () => ({}))

const mockSettings = {
  llm: {
    defaultProvider: 'claude',
    defaultModel: 'claude-sonnet-4',
    fallbackEnabled: true,
    fallbackOrder: ['gemini'],
    hasClaudeKey: true,
    hasGeminiKey: false,
    hasOpenaiKey: false
  },
  agents: {
    maxParallelAgents: 4,
    taskTimeoutMinutes: 30,
    maxRetries: 3,
    autoRetryEnabled: true
  },
  checkpoints: {
    autoCheckpointEnabled: true,
    autoCheckpointIntervalMinutes: 15,
    maxCheckpointsToKeep: 10,
    checkpointOnFeatureComplete: true
  },
  ui: {
    theme: 'system' as const,
    sidebarWidth: 280,
    showNotifications: true,
    notificationDuration: 4000
  },
  project: {
    defaultLanguage: 'typescript',
    defaultTestFramework: 'vitest',
    outputDirectory: './output'
  }
}

describe('settingsStore', () => {
  beforeEach(() => {
    useSettingsStore.setState({
      settings: null,
      isLoading: false,
      isDirty: false,
      pendingChanges: {}
    })

    // Mock window.api.settings
    vi.stubGlobal('window', {
      api: {
        settings: {
          getAll: vi.fn().mockResolvedValue(mockSettings),
          set: vi.fn().mockResolvedValue(true),
          setApiKey: vi.fn().mockResolvedValue(true),
          clearApiKey: vi.fn().mockResolvedValue(true)
        }
      }
    })
  })

  it('loads settings from main process', async () => {
    await useSettingsStore.getState().loadSettings()
    expect(useSettingsStore.getState().settings).toEqual(mockSettings)
  })

  it('tracks pending changes', () => {
    useSettingsStore.setState({ settings: mockSettings })
    useSettingsStore.getState().updateSetting('ui', 'theme', 'dark')
    expect(useSettingsStore.getState().isDirty).toBe(true)
  })

  it('saves pending changes to main process', async () => {
    useSettingsStore.setState({
      settings: mockSettings,
      pendingChanges: { ui: { theme: 'dark' } },
      isDirty: true
    })
    await useSettingsStore.getState().saveSettings()
    expect(window.api.settings.set).toHaveBeenCalled()
  })

  it('discards pending changes', () => {
    useSettingsStore.setState({
      settings: mockSettings,
      pendingChanges: { ui: { theme: 'dark' } },
      isDirty: true
    })
    useSettingsStore.getState().discardChanges()
    expect(useSettingsStore.getState().isDirty).toBe(false)
    expect(useSettingsStore.getState().pendingChanges).toEqual({})
  })
})
```

2. Create src/renderer/src/hooks/useKeyboardShortcuts.test.ts:
```typescript
import { describe, it, expect, vi } from 'vitest'
import { renderHook } from '@testing-library/react'
import { KEYBOARD_SHORTCUTS } from './useKeyboardShortcuts'

describe('KEYBOARD_SHORTCUTS', () => {
  it('defines all expected shortcuts', () => {
    const keys = KEYBOARD_SHORTCUTS.map(s => s.keys.join('+'))
    expect(keys).toContain('Cmd/Ctrl+N')
    expect(keys).toContain('Cmd/Ctrl+S')
    expect(keys).toContain('Cmd/Ctrl+,')
    expect(keys).toContain('?')
    expect(keys).toContain('Esc')
  })

  it('has descriptions for all shortcuts', () => {
    KEYBOARD_SHORTCUTS.forEach(shortcut => {
      expect(shortcut.description).toBeTruthy()
      expect(typeof shortcut.description).toBe('string')
    })
  })
})
```

3. Create src/renderer/src/components/ErrorBoundary.test.tsx:
```typescript
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'
import { ErrorBoundary } from './ErrorBoundary'

const ThrowError = ({ shouldThrow }: { shouldThrow: boolean }) => {
  if (shouldThrow) throw new Error('Test error')
  return <div>No error</div>
}

describe('ErrorBoundary', () => {
  // Suppress console.error for expected errors
  beforeEach(() => {
    vi.spyOn(console, 'error').mockImplementation(() => {})
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  it('renders children when no error', () => {
    render(
      <ErrorBoundary>
        <ThrowError shouldThrow={false} />
      </ErrorBoundary>
    )
    expect(screen.getByText('No error')).toBeInTheDocument()
  })

  it('shows error UI when error thrown', () => {
    render(
      <ErrorBoundary>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    )
    expect(screen.getByText('Something went wrong')).toBeInTheDocument()
    expect(screen.getByText('Test error')).toBeInTheDocument()
  })

  it('shows retry button that resets error state', () => {
    const { rerender } = render(
      <ErrorBoundary>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    )

    const retryButton = screen.getByRole('button', { name: /try again/i })
    expect(retryButton).toBeInTheDocument()

    // Click retry - component will throw again but that's expected behavior
    fireEvent.click(retryButton)
  })
})
```
  </action>
  <verify>pnpm test passes with new tests</verify>
  <done>Tests added for settingsStore, keyboard shortcuts, and ErrorBoundary</done>
</task>

<task type="auto">
  <name>Task 3: Verify production build and package</name>
  <files>package.json</files>
  <action>
1. Run all tests to ensure nothing is broken:
```bash
pnpm test
```
Verify all 1,400+ tests pass plus new Phase 12 tests.

2. Run type check:
```bash
pnpm typecheck
```
Verify no TypeScript errors.

3. Build the Electron app:
```bash
pnpm build:electron
```
Verify build succeeds without errors.

4. Check build output exists:
```bash
ls -la out/
```
Should see main/, preload/, renderer/ directories.

5. (Optional) If on Windows, test packaging:
```bash
# This creates installer in dist/
# May fail without code signing, but should produce unsigned build
npx electron-builder --win --dir
```
Check dist/ for output.

6. Verify the app launches from built files:
- The dev command should use the built output
- Confirm Settings page accessible
- Confirm theme toggle works
- Confirm keyboard shortcuts work

7. Document any issues found in SUMMARY.md
  </action>
  <verify>pnpm test passes, pnpm build:electron succeeds, app launches</verify>
  <done>All tests pass (1,400+), build succeeds, app is shippable</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm test` passes (1,400+ existing + ~30 new tests)
- [ ] `pnpm typecheck` passes
- [ ] `pnpm build:electron` succeeds
- [ ] README has installation, quick start, features
- [ ] Settings tests cover load, save, discard
- [ ] ErrorBoundary tests cover error display and retry
- [ ] Built app launches and works
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- README updated for end users
- New tests added for Phase 12 features
- Build and package verified
- Phase 12 complete
</success_criteria>

<output>
After completion, create `.planning/phases/12-polish/12-05-SUMMARY.md`

**Final Phase 12 Summary should include:**
- All 5 plans completed
- Total new tests added
- Definition of Done checklist verified
- Note: Phase 12 complete, project ready for release
</output>
