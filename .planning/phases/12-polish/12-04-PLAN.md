---
phase: 12-polish
plan: 04
type: execute
depends_on: []
files_modified: [src/renderer/src/App.tsx, src/renderer/src/components/ui/Skeleton.tsx, src/renderer/src/components/ErrorBoundary.tsx, src/renderer/src/pages/DashboardPage.tsx]
---

<objective>
Add animations with framer-motion, loading states, and error boundaries.

Purpose: Make the app feel polished with smooth transitions, informative loading states, and graceful error handling.
Output: Page transitions, skeleton loaders, spinner components, error boundaries with retry.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-polish/12-CONTEXT.md
@.planning/phases/12-polish/12-RESEARCH.md

**Relevant source files:**
@src/renderer/src/App.tsx
@src/renderer/src/pages/DashboardPage.tsx
@src/renderer/src/components/ui/

**From CONTEXT.md UI polish:**
- Skeleton loaders for Dashboard cards
- Spinner for LLM responses
- Page transitions (fade-in)
- Card hover effects
- Error boundaries with retry buttons
- Empty states with helpful messages

**From RESEARCH.md:**
- framer-motion AnimatePresence for exit animations
- Use `mode="wait"` to prevent layout shift
- Keep animations subtle (0.15s duration)

**Installation required:**
```bash
pnpm add framer-motion
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install framer-motion and add page transitions</name>
  <files>package.json, src/renderer/src/App.tsx, src/renderer/src/components/AnimatedPage.tsx</files>
  <action>
1. Run `pnpm add framer-motion`

2. Create src/renderer/src/components/AnimatedPage.tsx:
```tsx
import { motion } from 'framer-motion'
import { ReactNode } from 'react'

const pageVariants = {
  initial: { opacity: 0, y: 8 },
  animate: { opacity: 1, y: 0 },
  exit: { opacity: 0, y: -8 }
}

const pageTransition = {
  duration: 0.15,
  ease: 'easeOut'
}

interface AnimatedPageProps {
  children: ReactNode
  className?: string
}

export function AnimatedPage({ children, className }: AnimatedPageProps) {
  return (
    <motion.div
      variants={pageVariants}
      initial="initial"
      animate="animate"
      exit="exit"
      transition={pageTransition}
      className={className}
    >
      {children}
    </motion.div>
  )
}
```

3. Wrap each page component with AnimatedPage:
   - DashboardPage
   - SettingsPage
   - InterviewPage
   - KanbanPage

Example:
```tsx
export function DashboardPage() {
  return (
    <AnimatedPage className="p-6">
      {/* existing content */}
    </AnimatedPage>
  )
}
```

4. Note: AnimatePresence is needed at router level for exit animations. If using react-router, wrap the outlet or routes appropriately. Keep it simple â€” entrance animations are the priority.
  </action>
  <verify>Pages fade in when navigating, no layout shift</verify>
  <done>Page transitions work with framer-motion, subtle fade-in effect</done>
</task>

<task type="auto">
  <name>Task 2: Create loading components (Skeleton, Spinner)</name>
  <files>src/renderer/src/components/ui/Skeleton.tsx, src/renderer/src/components/ui/Spinner.tsx, src/renderer/src/components/ui/EmptyState.tsx</files>
  <action>
1. Create src/renderer/src/components/ui/Skeleton.tsx:
```tsx
import { cn } from '@renderer/lib/utils'

interface SkeletonProps {
  className?: string
}

export function Skeleton({ className }: SkeletonProps) {
  return (
    <div
      className={cn(
        'animate-pulse rounded-md bg-muted',
        className
      )}
    />
  )
}

// Pre-built skeleton patterns
export function CardSkeleton() {
  return (
    <div className="p-4 border rounded-lg space-y-3">
      <Skeleton className="h-4 w-1/3" />
      <Skeleton className="h-8 w-full" />
      <Skeleton className="h-4 w-2/3" />
    </div>
  )
}

export function ListSkeleton({ count = 3 }: { count?: number }) {
  return (
    <div className="space-y-2">
      {Array.from({ length: count }).map((_, i) => (
        <Skeleton key={i} className="h-12 w-full" />
      ))}
    </div>
  )
}
```

2. Create src/renderer/src/components/ui/Spinner.tsx:
```tsx
import { cn } from '@renderer/lib/utils'
import { Loader2 } from 'lucide-react'

interface SpinnerProps {
  size?: 'sm' | 'md' | 'lg'
  className?: string
}

const sizeClasses = {
  sm: 'h-4 w-4',
  md: 'h-6 w-6',
  lg: 'h-8 w-8'
}

export function Spinner({ size = 'md', className }: SpinnerProps) {
  return (
    <Loader2
      className={cn(
        'animate-spin text-muted-foreground',
        sizeClasses[size],
        className
      )}
    />
  )
}

export function LoadingOverlay({ message = 'Loading...' }: { message?: string }) {
  return (
    <div className="flex flex-col items-center justify-center gap-2 py-8">
      <Spinner size="lg" />
      <p className="text-sm text-muted-foreground">{message}</p>
    </div>
  )
}
```

3. Create src/renderer/src/components/ui/EmptyState.tsx:
```tsx
import { ReactNode } from 'react'
import { cn } from '@renderer/lib/utils'

interface EmptyStateProps {
  icon?: ReactNode
  title: string
  description?: string
  action?: ReactNode
  className?: string
}

export function EmptyState({ icon, title, description, action, className }: EmptyStateProps) {
  return (
    <div className={cn('flex flex-col items-center justify-center py-12 text-center', className)}>
      {icon && <div className="mb-4 text-muted-foreground">{icon}</div>}
      <h3 className="text-lg font-medium">{title}</h3>
      {description && (
        <p className="mt-1 text-sm text-muted-foreground max-w-sm">{description}</p>
      )}
      {action && <div className="mt-4">{action}</div>}
    </div>
  )
}
```

4. Export all from components/ui/index.ts
  </action>
  <verify>Skeleton animates with pulse, Spinner rotates, components render correctly</verify>
  <done>Skeleton, Spinner, LoadingOverlay, EmptyState components created</done>
</task>

<task type="auto">
  <name>Task 3: Create ErrorBoundary with retry and apply to app</name>
  <files>src/renderer/src/components/ErrorBoundary.tsx, src/renderer/src/App.tsx</files>
  <action>
1. Create src/renderer/src/components/ErrorBoundary.tsx:
```tsx
import { Component, ErrorInfo, ReactNode } from 'react'
import { Button } from './ui/button'
import { AlertTriangle, RefreshCw } from 'lucide-react'

interface Props {
  children: ReactNode
  fallback?: ReactNode
}

interface State {
  hasError: boolean
  error: Error | null
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = { hasError: false, error: null }
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    console.error('ErrorBoundary caught:', error, errorInfo)
  }

  handleRetry = (): void => {
    this.setState({ hasError: false, error: null })
  }

  render(): ReactNode {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback
      }

      return (
        <div className="flex flex-col items-center justify-center min-h-[400px] p-8 text-center">
          <AlertTriangle className="h-12 w-12 text-destructive mb-4" />
          <h2 className="text-xl font-semibold mb-2">Something went wrong</h2>
          <p className="text-muted-foreground mb-4 max-w-md">
            {this.state.error?.message || 'An unexpected error occurred'}
          </p>
          <Button onClick={this.handleRetry} variant="outline">
            <RefreshCw className="h-4 w-4 mr-2" />
            Try Again
          </Button>
        </div>
      )
    }

    return this.props.children
  }
}

// Hook-based error boundary wrapper for specific sections
export function withErrorBoundary<P extends object>(
  WrappedComponent: React.ComponentType<P>,
  fallback?: ReactNode
) {
  return function WithErrorBoundary(props: P) {
    return (
      <ErrorBoundary fallback={fallback}>
        <WrappedComponent {...props} />
      </ErrorBoundary>
    )
  }
}
```

2. Wrap the main app content in App.tsx with ErrorBoundary:
```tsx
import { ErrorBoundary } from './components/ErrorBoundary'

function App() {
  // ...

  return (
    <ErrorBoundary>
      <RouterProvider router={router} />
      <Toaster ... />
      <KeyboardShortcutsModal />
    </ErrorBoundary>
  )
}
```

3. Add loading skeletons to DashboardPage for metrics cards:
```tsx
// In DashboardPage, when loading:
{isLoading ? (
  <div className="grid grid-cols-4 gap-4">
    <CardSkeleton />
    <CardSkeleton />
    <CardSkeleton />
    <CardSkeleton />
  </div>
) : (
  // ... existing metrics cards
)}
```
  </action>
  <verify>Error boundary catches errors and shows retry button, skeleton shows during loading</verify>
  <done>ErrorBoundary wraps app, loading states in Dashboard, retry works</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm run build:electron` succeeds
- [ ] `pnpm run typecheck` passes
- [ ] framer-motion installed
- [ ] Pages animate on navigation (fade-in)
- [ ] Skeleton components show pulse animation
- [ ] Spinner rotates correctly
- [ ] ErrorBoundary catches errors and shows retry
- [ ] Dashboard shows loading skeletons
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Page transitions smooth and subtle
- Loading states informative
- Errors handled gracefully with retry option
- No layout shift during animations
</success_criteria>

<output>
After completion, create `.planning/phases/12-polish/12-04-SUMMARY.md`
</output>
