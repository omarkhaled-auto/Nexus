---
phase: 03-llm-agents
plan: 03
type: tdd
depends_on: [03-01]
files_modified: [src/quality/build/BuildVerifier.ts, src/quality/build/BuildVerifier.test.ts, src/quality/lint/LintRunner.ts, src/quality/lint/LintRunner.test.ts, src/quality/test/TestRunner.ts, src/quality/test/TestRunner.test.ts, src/quality/review/CodeReviewer.ts, src/quality/review/CodeReviewer.test.ts, src/execution/qa-loop/QALoopEngine.ts, src/execution/qa-loop/QALoopEngine.test.ts, src/quality/types.ts, src/quality/index.ts]
domain: quality
---

<objective>
Implement quality verification layer and QA loop engine.

Purpose: Ensure code quality through automated Build → Lint → Test → Review cycle. The QA loop iterates until code passes all checks or escalates to human. This is the self-healing mechanism that enables autonomous code generation.
Output: Working BuildVerifier, LintRunner, TestRunner, CodeReviewer, and QALoopEngine.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
./.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plans (03-01 must complete first, 03-02 and 03-03 can run in parallel):
@.planning/phases/03-llm-agents/03-01-PLAN.md
@.planning/phases/03-llm-agents/03-02-PLAN.md

# Master Book reference:
@07_NEXUS_MASTER_BOOK.md (Section 4.4, BUILD-010)

# Existing infrastructure:
@src/infrastructure/process/ProcessRunner.ts

**QA Loop Flow:**
1. Build (TypeScript compilation)
2. Lint (ESLint)
3. Test (Vitest)
4. Review (AI code review)
5. If any fail → Coder fixes → Loop
6. Max 50 iterations → Escalate to human

**Established patterns:**
- Custom error types with Object.setPrototypeOf
- Optional logger injection
- TDD: RED-GREEN-REFACTOR
</context>

<feature>
  <name>Quality Types and Interfaces</name>
  <files>src/quality/types.ts</files>
  <behavior>
    VerificationResult:
    - success: boolean
    - errors: VerificationError[]
    - warnings: VerificationWarning[]
    - duration: number (ms)

    VerificationError:
    - type: 'build' | 'lint' | 'test' | 'review'
    - file: string
    - line?: number
    - column?: number
    - message: string
    - code?: string (error code)

    VerificationWarning:
    - type: 'build' | 'lint' | 'test' | 'review'
    - file: string
    - line?: number
    - message: string

    TestResult:
    - success: boolean
    - passed: number
    - failed: number
    - skipped: number
    - coverage?: CoverageReport
    - failures: TestFailure[]

    TestFailure:
    - testName: string
    - file: string
    - message: string
    - stack?: string

    CoverageReport:
    - lines: number (percentage)
    - functions: number
    - branches: number
    - statements: number

    QAResult:
    - success: boolean
    - iterations: number
    - escalated: boolean
    - stages: StageResult[]
    - finalErrors?: VerificationError[]

    StageResult:
    - stage: 'build' | 'lint' | 'test' | 'review'
    - passed: boolean
    - duration: number
    - errors?: VerificationError[]
  </behavior>
  <implementation>
    Define TypeScript interfaces and types.
    Export all types for use by other modules.
  </implementation>
</feature>

<feature>
  <name>BuildVerifier - TypeScript Compilation Check</name>
  <files>src/quality/build/BuildVerifier.ts, src/quality/build/BuildVerifier.test.ts</files>
  <behavior>
    Error Types:
    - BuildError: Compilation failed
    - ConfigError: tsconfig.json invalid

    Constructor:
    - Accept processRunner: ProcessRunner
    - Accept optional tscPath (default: 'npx tsc')
    - Accept optional logger

    Methods:
    - verify(workdir: string): Promise<VerificationResult>
    - parseErrors(output: string): VerificationError[]

    Error Parsing:
    - Parse TypeScript compiler output
    - Extract file, line, column, message
    - Handle both tsc and esbuild error formats

    Cases:
    - Clean build → success: true, no errors
    - Type error → success: false, error with location
    - Multiple errors → all parsed and returned
    - Missing tsconfig → ConfigError
    - Parse various error formats correctly
  </behavior>
  <implementation>
    Run `tsc --noEmit` via ProcessRunner.
    Parse stdout/stderr for errors.
    Use regex to extract error details.
  </implementation>
</feature>

<feature>
  <name>LintRunner - ESLint Execution</name>
  <files>src/quality/lint/LintRunner.ts, src/quality/lint/LintRunner.test.ts</files>
  <behavior>
    Error Types:
    - LintError: Linting failed
    - ConfigError: ESLint config invalid

    Constructor:
    - Accept processRunner: ProcessRunner
    - Accept optional eslintPath (default: 'npx eslint')
    - Accept optional logger

    Methods:
    - run(workdir: string, files?: string[]): Promise<VerificationResult>
    - runWithFix(workdir: string, files?: string[]): Promise<VerificationResult>
    - parseOutput(output: string): VerificationError[]

    Features:
    - Run ESLint with JSON output format
    - Support auto-fix mode
    - Distinguish errors from warnings

    Cases:
    - Clean code → success: true
    - Lint error → success: false, errors listed
    - Lint warning → success: true, warnings listed
    - Auto-fix resolves issues → success: true
    - Multiple files → all checked
    - Missing config → uses defaults
  </behavior>
  <implementation>
    Run `eslint --format json` via ProcessRunner.
    Parse JSON output for structured errors.
    Use --fix flag for auto-fix mode.
  </implementation>
</feature>

<feature>
  <name>TestRunner - Vitest Execution</name>
  <files>src/quality/test/TestRunner.ts, src/quality/test/TestRunner.test.ts</files>
  <behavior>
    Error Types:
    - TestError: Test execution failed
    - TimeoutError: Tests timed out

    Constructor:
    - Accept processRunner: ProcessRunner
    - Accept optional vitestPath (default: 'npx vitest')
    - Accept optional timeout (default: 300000ms)
    - Accept optional logger

    Methods:
    - run(workdir: string, testPattern?: string): Promise<TestResult>
    - runWithCoverage(workdir: string): Promise<TestResult>
    - parseOutput(output: string): TestResult

    Features:
    - Run specific tests by pattern
    - Collect coverage metrics
    - Parse failure details

    Cases:
    - All tests pass → success: true, passed count
    - Test fails → success: false, failure details
    - Tests timeout → TimeoutError
    - Coverage collected → coverage report included
    - Test pattern filters correctly
  </behavior>
  <implementation>
    Run `vitest run --reporter=json` via ProcessRunner.
    Parse JSON output for results.
    Use --coverage flag for coverage mode.
  </implementation>
</feature>

<feature>
  <name>CodeReviewer - AI Code Review</name>
  <files>src/quality/review/CodeReviewer.ts, src/quality/review/CodeReviewer.test.ts</files>
  <behavior>
    Error Types:
    - ReviewError: Review failed

    Constructor:
    - Accept llmProvider: LLMProvider
    - Accept optional logger

    Methods:
    - review(files: FileChange[]): Promise<ReviewResult>
    - reviewDiff(diff: string): Promise<ReviewResult>

    FileChange:
    - path: string
    - content: string
    - diff?: string

    ReviewResult:
    - approved: boolean
    - hasBlockingIssues: boolean
    - issues: ReviewIssue[]
    - summary: string

    ReviewIssue:
    - severity: 'critical' | 'major' | 'minor' | 'suggestion'
    - file: string
    - line?: number
    - message: string
    - suggestion?: string

    Blocking Issues:
    - critical severity → always blocking
    - major severity → blocking if > 2 issues
    - minor/suggestion → never blocking

    Cases:
    - Clean code → approved: true
    - Security issue → critical issue, not approved
    - Style issue → suggestion, approved
    - Multiple issues categorized correctly
    - Large diff handled (uses Gemini's large context)
  </behavior>
  <implementation>
    Use ReviewerRunner (or direct LLMProvider.getClient('reviewer')).
    Parse structured JSON from AI response.
    Categorize issues by severity.
  </implementation>
</feature>

<feature>
  <name>QALoopEngine - Self-Healing QA Loop</name>
  <files>src/execution/qa-loop/QALoopEngine.ts, src/execution/qa-loop/QALoopEngine.test.ts</files>
  <behavior>
    Error Types:
    - QAError: QA loop failed
    - EscalationError: Max iterations reached

    Constructor:
    - Accept buildVerifier: BuildVerifier
    - Accept lintRunner: LintRunner
    - Accept testRunner: TestRunner
    - Accept codeReviewer: CodeReviewer
    - Accept optional maxIterations (default: 50)
    - Accept optional logger

    Methods:
    - run(task: Task, coder: CoderRunner): Promise<QAResult>
    - runStage(stage: string, workdir: string): Promise<VerificationResult>

    Loop Logic:
    ```
    for iteration in 1..maxIterations:
      1. buildResult = buildVerifier.verify(worktree)
         if !buildResult.success → coder.fixIssues(buildResult.errors) → continue

      2. lintResult = lintRunner.run(worktree)
         if !lintResult.success → coder.fixIssues(lintResult.errors) → continue

      3. testResult = testRunner.run(worktree, task.test)
         if !testResult.success → coder.fixIssues(testResult.failures) → continue

      4. reviewResult = codeReviewer.review(task.files)
         if reviewResult.hasBlockingIssues → coder.fixIssues(reviewResult.issues) → continue

      return { success: true, iterations }

    return { success: false, escalated: true, iterations: maxIterations }
    ```

    Events Emitted:
    - qa:iteration:start { iteration, stage }
    - qa:iteration:complete { iteration, stage, success }
    - qa:escalation { task, iterations, errors }

    Cases:
    - All pass first try → success, iterations: 1
    - Build fails, fix, pass → success, iterations: 2
    - Multiple fixes needed → tracks all iterations
    - Max iterations → escalated: true
    - Each stage tracked in result.stages
  </behavior>
  <implementation>
    Implement main loop with stage progression.
    Feed errors back to coder for fixes.
    Track iteration count and stage results.
  </implementation>
</feature>

<verification>
- [ ] `pnpm test -- --grep "BuildVerifier"` - All tests pass
- [ ] `pnpm test -- --grep "LintRunner"` - All tests pass
- [ ] `pnpm test -- --grep "TestRunner"` - All tests pass
- [ ] `pnpm test -- --grep "CodeReviewer"` - All tests pass
- [ ] `pnpm test -- --grep "QALoopEngine"` - All tests pass
- [ ] `pnpm typecheck` passes
- [ ] `pnpm lint` passes for new files
</verification>

<success_criteria>
- All tests pass (target: 50+ tests)
- BuildVerifier parses TypeScript errors correctly
- LintRunner executes ESLint with auto-fix
- TestRunner collects coverage
- CodeReviewer produces structured reviews
- QALoopEngine runs complete cycle
- Escalation works at max iterations
- Phase 3 milestone: Single agent completes task through QA loop
</success_criteria>

<output>
After completion, create `.planning/phases/03-llm-agents/03-03-SUMMARY.md` following the summary template with TDD-specific sections.
</output>
