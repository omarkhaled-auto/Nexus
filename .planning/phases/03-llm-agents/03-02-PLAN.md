---
phase: 03-llm-agents
plan: 02
type: tdd
depends_on: [03-01]
files_modified: [src/execution/agents/AgentRunner.ts, src/execution/agents/AgentRunner.test.ts, src/execution/agents/CoderRunner.ts, src/execution/agents/CoderRunner.test.ts, src/execution/agents/TesterRunner.ts, src/execution/agents/TesterRunner.test.ts, src/execution/agents/ReviewerRunner.ts, src/execution/agents/ReviewerRunner.test.ts, src/execution/agents/MergerRunner.ts, src/execution/agents/MergerRunner.test.ts, src/execution/agents/types.ts, src/execution/agents/index.ts, config/prompts/coder.md, config/prompts/tester.md, config/prompts/reviewer.md, config/prompts/merger.md]
domain: execution
---

<objective>
Implement agent execution framework with all agent types.

Purpose: Create the agent runners that execute tasks using LLM clients. Each agent type has specific capabilities, tools, and system prompts. This enables Nexus to perform code generation, testing, review, and merging.
Output: Working AgentRunner base class and CoderRunner, TesterRunner, ReviewerRunner, MergerRunner implementations with system prompts.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
./.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan (must complete first):
@.planning/phases/03-llm-agents/03-01-PLAN.md

# Master Book reference:
@07_NEXUS_MASTER_BOOK.md (Section 4.4, BUILD-009)

# Existing infrastructure:
@src/infrastructure/file-system/FileSystemService.ts
@src/infrastructure/process/ProcessRunner.ts
@src/infrastructure/git/GitService.ts

**Agent Tool Permissions (from Master Book):**
| Agent | Tools |
|-------|-------|
| Planner | read, search, analyze |
| Coder | read, write, edit, bash |
| Tester | read, write, bash |
| Reviewer | read, search |
| Merger | git, read, write |

**Established patterns:**
- Custom error types with Object.setPrototypeOf
- Optional logger injection
- TDD: RED-GREEN-REFACTOR
</context>

<feature>
  <name>Agent Types and Interfaces</name>
  <files>src/execution/agents/types.ts</files>
  <behavior>
    Task:
    - id: string
    - name: string
    - description: string
    - files: string[] (target files)
    - test?: string (test command)
    - worktree?: string (isolated worktree path)

    ExecutionResult:
    - success: boolean
    - filesChanged: string[]
    - output: string
    - error?: string
    - iterations: number
    - tokenUsage: TokenUsage

    AgentContext:
    - task: Task
    - llmClient: LLMClient
    - tools: ToolExecutor
    - logger?: Logger
    - maxIterations: number (default: 10)

    ToolExecutor:
    - execute(name: string, params: Record<string, unknown>): Promise<ToolResult>
    - getAvailableTools(): ToolDefinition[]

    AgentState:
    - 'idle' | 'running' | 'waiting_tool' | 'completed' | 'failed'
  </behavior>
  <implementation>
    Define TypeScript interfaces and types.
    Export all types for use by other modules.
  </implementation>
</feature>

<feature>
  <name>AgentRunner - Base Agent Class</name>
  <files>src/execution/agents/AgentRunner.ts, src/execution/agents/AgentRunner.test.ts</files>
  <behavior>
    Error Types:
    - AgentError: Base error
    - MaxIterationsError: Exceeded max iterations
    - ToolExecutionError: Tool failed
    - LLMError: LLM call failed

    Constructor:
    - Accept llmProvider: LLMProvider
    - Accept toolExecutor: ToolExecutor
    - Accept optional logger
    - Accept optional maxIterations (default: 10)

    Abstract Properties:
    - agentType: AgentType
    - systemPrompt: string

    Methods:
    - execute(task: Task): Promise<ExecutionResult>
    - getState(): AgentState
    - cancel(): void

    Protected Methods:
    - buildMessages(task: Task, history: Message[]): Message[]
    - handleToolCalls(toolCalls: ToolCall[]): Promise<ToolResult[]>
    - shouldContinue(response: Response, iteration: number): boolean

    Execution Loop:
    1. Build initial messages with system prompt + task
    2. Call LLM
    3. If tool_use → execute tools, add results, loop
    4. If stop → extract result, return
    5. If max_tokens or error → handle appropriately
    6. Track iterations, fail if > maxIterations

    Cases:
    - execute runs to completion
    - Tool calls are executed and results returned to LLM
    - Max iterations triggers MaxIterationsError
    - LLM error propagates as LLMError
    - Tool error captured and sent to LLM for recovery
    - cancel() stops execution
    - getState() reflects current state
  </behavior>
  <implementation>
    Use async loop with tool call handling.
    Build conversation history for context.
    Track state transitions.
  </implementation>
</feature>

<feature>
  <name>CoderRunner - Code Generation Agent</name>
  <files>src/execution/agents/CoderRunner.ts, src/execution/agents/CoderRunner.test.ts, config/prompts/coder.md</files>
  <behavior>
    Extends: AgentRunner

    Tools Available:
    - read_file(path: string): string
    - write_file(path: string, content: string): void
    - edit_file(path: string, edits: Edit[]): void
    - run_command(command: string): CommandResult
    - search_code(query: string, path?: string): SearchResult[]

    System Prompt (config/prompts/coder.md):
    - Role: Code generation and modification
    - Constraints: 30-min tasks, follow patterns, write tests
    - Output format: Files to modify, code, tests

    Special Behaviors:
    - Extracts filesChanged from tool calls
    - Validates code compiles before completion
    - Follows existing code patterns

    Cases:
    - Generate new file → write_file tool used
    - Modify existing file → edit_file tool used
    - Multiple files changed → all tracked in result
    - Test written alongside implementation
    - Build error → attempts fix
  </behavior>
  <implementation>
    Override buildMessages to inject coder-specific context.
    Track file operations for filesChanged result.
    Use ProcessRunner for command execution.
  </implementation>
</feature>

<feature>
  <name>TesterRunner - Test Writing Agent</name>
  <files>src/execution/agents/TesterRunner.ts, src/execution/agents/TesterRunner.test.ts, config/prompts/tester.md</files>
  <behavior>
    Extends: AgentRunner

    Tools Available:
    - read_file(path: string): string
    - write_file(path: string, content: string): void
    - run_command(command: string): CommandResult

    System Prompt (config/prompts/tester.md):
    - Role: Test creation and execution
    - Constraints: High coverage, edge cases, clear assertions
    - Output format: Test files, coverage report

    Special Behaviors:
    - Analyzes source code to understand what to test
    - Runs tests to verify they pass
    - Reports coverage metrics

    Cases:
    - Write tests for function → test file created
    - Tests run and pass → success
    - Tests fail → attempts fix
    - Coverage reported in output
  </behavior>
  <implementation>
    Override buildMessages to inject tester-specific context.
    Run tests after writing to validate.
  </implementation>
</feature>

<feature>
  <name>ReviewerRunner - Code Review Agent</name>
  <files>src/execution/agents/ReviewerRunner.ts, src/execution/agents/ReviewerRunner.test.ts, config/prompts/reviewer.md</files>
  <behavior>
    Extends: AgentRunner

    Tools Available:
    - read_file(path: string): string
    - search_code(query: string, path?: string): SearchResult[]

    System Prompt (config/prompts/reviewer.md):
    - Role: Code review with structured feedback
    - Constraints: Focus on bugs, security, patterns
    - Output format: Structured review with severity

    ReviewResult (output format):
    - approved: boolean
    - issues: ReviewIssue[]
    - summary: string

    ReviewIssue:
    - severity: 'critical' | 'major' | 'minor' | 'suggestion'
    - file: string
    - line?: number
    - message: string
    - suggestion?: string

    Special Behaviors:
    - Uses Gemini for large context review
    - Produces structured JSON output
    - Categorizes issues by severity

    Cases:
    - Review clean code → approved: true, no issues
    - Review buggy code → approved: false, issues listed
    - Review with suggestions → approved: true, minor issues
    - Large file reviewed successfully (Gemini's large context)
  </behavior>
  <implementation>
    Use GeminiClient (via LLMProvider).
    Parse structured output from review.
    Override shouldContinue for single-pass review.
  </implementation>
</feature>

<feature>
  <name>MergerRunner - Branch Merge Agent</name>
  <files>src/execution/agents/MergerRunner.ts, src/execution/agents/MergerRunner.test.ts, config/prompts/merger.md</files>
  <behavior>
    Extends: AgentRunner

    Tools Available:
    - git_diff(branch: string): string
    - git_merge(branch: string): MergeResult
    - git_status(): GitStatus
    - read_file(path: string): string
    - write_file(path: string, content: string): void

    System Prompt (config/prompts/merger.md):
    - Role: Branch merging and conflict resolution
    - Constraints: Preserve functionality, resolve conflicts
    - Output format: Merge status, resolved conflicts

    Special Behaviors:
    - Detects merge conflicts
    - Resolves conflicts using code understanding
    - Validates merge doesn't break build

    Cases:
    - Clean merge → success, no conflicts
    - Conflict detected → attempts resolution
    - Conflict resolved → files updated, merge completed
    - Unresolvable conflict → escalates
  </behavior>
  <implementation>
    Use GitService for git operations.
    Conflict resolution via code analysis.
  </implementation>
</feature>

<verification>
- [ ] `pnpm test -- --grep "AgentRunner"` - All tests pass
- [ ] `pnpm test -- --grep "CoderRunner"` - All tests pass
- [ ] `pnpm test -- --grep "TesterRunner"` - All tests pass
- [ ] `pnpm test -- --grep "ReviewerRunner"` - All tests pass
- [ ] `pnpm test -- --grep "MergerRunner"` - All tests pass
- [ ] `pnpm typecheck` passes
- [ ] `pnpm lint` passes for new files
</verification>

<success_criteria>
- All tests pass (target: 50+ tests)
- Base AgentRunner handles tool loop correctly
- Each agent type has correct tools and behavior
- System prompts are comprehensive
- Agents can complete simple tasks
- Ready for BUILD-010 (Quality Layer) integration
</success_criteria>

<output>
After completion, create `.planning/phases/03-llm-agents/03-02-SUMMARY.md` following the summary template with TDD-specific sections.
</output>
