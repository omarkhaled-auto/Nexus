---
phase: 11-integration-testing
plan: 01
type: execute
depends_on: []
files_modified: [tests/mocks/handlers.ts, tests/mocks/node.ts, tests/helpers/fixtures.ts, tests/helpers/testDb.ts, tests/factories/index.ts, vitest.setup.ts]
---

<objective>
Set up test infrastructure for integration and E2E testing.

Purpose: Create reusable test utilities (MSW mocking, Vitest fixtures, test factories) that all integration tests will use.
Output: Working test infrastructure with MSW intercepting LLM APIs, typed fixtures for DB/EventBus, and factories for domain objects.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-integration-testing/11-CONTEXT.md
@.planning/phases/11-integration-testing/11-RESEARCH.md

**Key source files:**
@src/llm/clients/ClaudeClient.ts
@src/llm/clients/GeminiClient.ts
@src/orchestration/events/EventBus.ts
@src/persistence/database.ts
@src/types/index.ts

**From RESEARCH.md - Don't hand-roll:**
- API mocking: Use MSW (not manual fetch mocks)
- Stream mocking: Use MSW ReadableStream
- Test fixtures: Use Vitest test.extend (not scattered beforeEach/afterEach)
- Test data: Use factories (not inline literals)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install MSW and create LLM mock handlers</name>
  <files>package.json, tests/mocks/handlers.ts, tests/mocks/node.ts</files>
  <action>
1. Install MSW: `npm install -D msw@latest`
2. Create `tests/mocks/handlers.ts` with:
   - Claude API mock (POST https://api.anthropic.com/v1/messages) with streaming response using ReadableStream
   - Gemini API mock (POST https://generativelanguage.googleapis.com/*) with JSON response
   - Include realistic response structures matching actual API schemas
3. Create `tests/mocks/node.ts` that exports `server = setupServer(...handlers)`

Use MSW's `http.post()` and `HttpResponse` for mocking. For Claude streaming, use ReadableStream with SSE format (event: content_block_delta).
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit tests/mocks/*.ts`</verify>
  <done>MSW handlers exist for Claude and Gemini APIs, server exported from node.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create Vitest fixtures and update setup</name>
  <files>tests/helpers/fixtures.ts, tests/helpers/testDb.ts, vitest.setup.ts</files>
  <action>
1. Create `tests/helpers/testDb.ts`:
   - `createTestDatabase()` function that creates an in-memory SQLite database
   - `TestDatabase` class with `cleanup()` method for teardown
   - Use the same schema as production (import from src/persistence/schema.ts)

2. Create `tests/helpers/fixtures.ts`:
   - Export `test` from `baseTest.extend<TestFixtures>()` with:
     - `db`: Creates TestDatabase, calls cleanup after
     - `eventBus`: Creates fresh EventBus, removes listeners after
   - Type TestFixtures interface properly

3. Update `vitest.setup.ts` to add MSW lifecycle:
   - `beforeAll(() => server.listen({ onUnhandledRequest: 'error' }))`
   - `afterEach(() => server.resetHandlers())`
   - `afterAll(() => server.close())`
  </action>
  <verify>Run: `npm test -- --run tests/helpers/fixtures.test.ts` (create a simple test to verify fixtures work)</verify>
  <done>Fixtures provide db and eventBus, MSW starts/stops with test lifecycle</done>
</task>

<task type="auto">
  <name>Task 3: Create test factories for domain objects</name>
  <files>tests/factories/index.ts</files>
  <action>
Create factory functions that generate valid test instances of domain objects:

1. `createTask(overrides?: Partial<Task>): Task` - id, title, status, dependencies, estimatedMinutes
2. `createFeature(overrides?: Partial<Feature>): Feature` - id, name, complexity, tasks
3. `createRequirement(overrides?: Partial<Requirement>): Requirement` - id, text, category, priority, source
4. `createProject(overrides?: Partial<Project>): Project` - id, name, mode, createdAt
5. `createAgent(overrides?: Partial<AgentState>): AgentState` - id, type, status, taskId

Use an incrementing counter for unique IDs. Provide sensible defaults. Allow overrides for any property.

Export helper: `createTasks(count: number, overrides?: Partial<Task>): Task[]`
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit tests/factories/index.ts`</verify>
  <done>Factory functions exist for Task, Feature, Requirement, Project, Agent with proper types</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm install` succeeds (MSW added)
- [ ] `npx tsc --noEmit` passes for all new test files
- [ ] MSW handlers exist for Claude and Gemini
- [ ] Fixtures provide typed db and eventBus
- [ ] Factories create valid domain objects
</verification>

<success_criteria>

- MSW installed and handlers created
- Vitest fixtures working with proper cleanup
- Test factories for all domain objects
- vitest.setup.ts integrates MSW lifecycle
</success_criteria>

<output>
After completion, create `.planning/phases/11-integration-testing/11-01-SUMMARY.md`
</output>
