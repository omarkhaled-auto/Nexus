---
phase: 10-human-checkpoints
plan: 03
type: execute
depends_on: ["10-02"]
files_modified: [src/main/ipc/handlers.ts, src/preload/index.ts, src/renderer/src/hooks/useCheckpoint.ts, src/renderer/src/components/checkpoints/CheckpointList.tsx, src/renderer/src/components/checkpoints/CheckpointList.test.tsx, src/renderer/src/components/checkpoints/ReviewModal.tsx, src/renderer/src/components/checkpoints/ReviewModal.test.tsx, src/renderer/src/components/checkpoints/index.ts]
---

<objective>
Create IPC handlers for checkpoint/review operations and UI components for checkpoint history and review modals.

Purpose: Enable renderer process to interact with checkpoint system and display review requests.
Output: IPC handlers, useCheckpoint hook, CheckpointList and ReviewModal components.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-human-checkpoints/10-CONTEXT.md
@.planning/phases/10-human-checkpoints/10-RESEARCH.md
@.planning/phases/10-human-checkpoints/10-01-SUMMARY.md
@.planning/phases/10-human-checkpoints/10-02-SUMMARY.md
@src/main/ipc/handlers.ts
@src/preload/index.ts
@src/renderer/src/hooks/useInterview.ts
@src/renderer/src/components/interview/RequirementsSidebar.tsx

**Constraining decisions:**
- Phase 05-04: UIBackendBridge in renderer
- Phase 07-04: IPC for EventBus from renderer

**Patterns to follow:**
- Existing IPC handler pattern in handlers.ts
- Existing preload API exposure pattern
- Existing hook patterns (useInterview.ts)
- shadcn/ui component patterns
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add checkpoint/review IPC handlers</name>
  <files>src/main/ipc/handlers.ts, src/preload/index.ts</files>
  <action>
**In handlers.ts:**

Add new IPC handlers following existing pattern:

```typescript
// Checkpoint handlers
ipcMain.handle('checkpoint:list', async (_, projectId: string) => {
  return checkpointManager.listCheckpoints(projectId);
});

ipcMain.handle('checkpoint:create', async (_, projectId: string, reason: string) => {
  return checkpointManager.createCheckpoint(projectId, reason);
});

ipcMain.handle('checkpoint:restore', async (_, checkpointId: string, restoreGit?: boolean) => {
  await checkpointManager.restoreCheckpoint(checkpointId, { restoreGit });
});

ipcMain.handle('checkpoint:delete', async (_, checkpointId: string) => {
  checkpointManager.deleteCheckpoint(checkpointId);
});

// Review handlers
ipcMain.handle('review:list', async () => {
  return humanReviewService.listPendingReviews();
});

ipcMain.handle('review:get', async (_, reviewId: string) => {
  return humanReviewService.getReview(reviewId);
});

ipcMain.handle('review:approve', async (_, reviewId: string, resolution?: string) => {
  await humanReviewService.approveReview(reviewId, resolution);
});

ipcMain.handle('review:reject', async (_, reviewId: string, feedback: string) => {
  await humanReviewService.rejectReview(reviewId, feedback);
});
```

Note: CheckpointManager and HumanReviewService instances should be passed to the handler registration function. Follow existing pattern for service injection.

**In preload/index.ts:**

Add to contextBridge.exposeInMainWorld('api', ...):

```typescript
// Checkpoint API
checkpointList: (projectId: string) => ipcRenderer.invoke('checkpoint:list', projectId),
checkpointCreate: (projectId: string, reason: string) => ipcRenderer.invoke('checkpoint:create', projectId, reason),
checkpointRestore: (checkpointId: string, restoreGit?: boolean) => ipcRenderer.invoke('checkpoint:restore', checkpointId, restoreGit),
checkpointDelete: (checkpointId: string) => ipcRenderer.invoke('checkpoint:delete', checkpointId),

// Review API
reviewList: () => ipcRenderer.invoke('review:list'),
reviewGet: (reviewId: string) => ipcRenderer.invoke('review:get', reviewId),
reviewApprove: (reviewId: string, resolution?: string) => ipcRenderer.invoke('review:approve', reviewId, resolution),
reviewReject: (reviewId: string, feedback: string) => ipcRenderer.invoke('review:reject', reviewId, feedback),
```

Update the API type definition in preload to include these methods.
  </action>
  <verify>npm run typecheck passes, IPC handlers properly typed</verify>
  <done>8 IPC handlers added for checkpoint and review operations</done>
</task>

<task type="auto">
  <name>Task 2: Create useCheckpoint hook</name>
  <files>src/renderer/src/hooks/useCheckpoint.ts</files>
  <action>
Create useCheckpoint hook following useInterview pattern:

```typescript
import { useState, useCallback, useEffect } from 'react';
import type { Checkpoint } from '@/persistence/database/schema';
import type { HumanReviewRequest } from '@/orchestration/review/HumanReviewService';

interface UseCheckpointReturn {
  // Checkpoint state
  checkpoints: Checkpoint[];
  isLoading: boolean;
  error: string | null;

  // Checkpoint actions
  loadCheckpoints: (projectId: string) => Promise<void>;
  createCheckpoint: (projectId: string, reason: string) => Promise<void>;
  restoreCheckpoint: (checkpointId: string, restoreGit?: boolean) => Promise<void>;
  deleteCheckpoint: (checkpointId: string) => Promise<void>;

  // Review state
  pendingReviews: HumanReviewRequest[];
  activeReview: HumanReviewRequest | null;

  // Review actions
  loadPendingReviews: () => Promise<void>;
  approveReview: (reviewId: string, resolution?: string) => Promise<void>;
  rejectReview: (reviewId: string, feedback: string) => Promise<void>;
}

export function useCheckpoint(): UseCheckpointReturn {
  const [checkpoints, setCheckpoints] = useState<Checkpoint[]>([]);
  const [pendingReviews, setPendingReviews] = useState<HumanReviewRequest[]>([]);
  const [activeReview, setActiveReview] = useState<HumanReviewRequest | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const loadCheckpoints = useCallback(async (projectId: string) => {
    setIsLoading(true);
    setError(null);
    try {
      const result = await window.api.checkpointList(projectId);
      setCheckpoints(result);
    } catch (err) {
      setError((err as Error).message);
    } finally {
      setIsLoading(false);
    }
  }, []);

  const createCheckpoint = useCallback(async (projectId: string, reason: string) => {
    setIsLoading(true);
    try {
      await window.api.checkpointCreate(projectId, reason);
      await loadCheckpoints(projectId);
    } catch (err) {
      setError((err as Error).message);
    } finally {
      setIsLoading(false);
    }
  }, [loadCheckpoints]);

  const restoreCheckpoint = useCallback(async (checkpointId: string, restoreGit?: boolean) => {
    setIsLoading(true);
    try {
      await window.api.checkpointRestore(checkpointId, restoreGit);
    } catch (err) {
      setError((err as Error).message);
    } finally {
      setIsLoading(false);
    }
  }, []);

  const deleteCheckpoint = useCallback(async (checkpointId: string) => {
    setIsLoading(true);
    try {
      await window.api.checkpointDelete(checkpointId);
      setCheckpoints(prev => prev.filter(cp => cp.id !== checkpointId));
    } catch (err) {
      setError((err as Error).message);
    } finally {
      setIsLoading(false);
    }
  }, []);

  const loadPendingReviews = useCallback(async () => {
    try {
      const reviews = await window.api.reviewList();
      setPendingReviews(reviews);
      // Set active review to first pending if exists
      if (reviews.length > 0 && !activeReview) {
        setActiveReview(reviews[0]);
      }
    } catch (err) {
      setError((err as Error).message);
    }
  }, [activeReview]);

  const approveReview = useCallback(async (reviewId: string, resolution?: string) => {
    try {
      await window.api.reviewApprove(reviewId, resolution);
      setPendingReviews(prev => prev.filter(r => r.id !== reviewId));
      if (activeReview?.id === reviewId) {
        setActiveReview(null);
      }
    } catch (err) {
      setError((err as Error).message);
    }
  }, [activeReview]);

  const rejectReview = useCallback(async (reviewId: string, feedback: string) => {
    try {
      await window.api.reviewReject(reviewId, feedback);
      setPendingReviews(prev => prev.filter(r => r.id !== reviewId));
      if (activeReview?.id === reviewId) {
        setActiveReview(null);
      }
    } catch (err) {
      setError((err as Error).message);
    }
  }, [activeReview]);

  return {
    checkpoints,
    isLoading,
    error,
    loadCheckpoints,
    createCheckpoint,
    restoreCheckpoint,
    deleteCheckpoint,
    pendingReviews,
    activeReview,
    loadPendingReviews,
    approveReview,
    rejectReview,
  };
}
```

Export from hooks/index.ts if exists.
  </action>
  <verify>npm run typecheck passes for renderer</verify>
  <done>useCheckpoint hook created with checkpoint and review operations</done>
</task>

<task type="auto">
  <name>Task 3: Create CheckpointList and ReviewModal components</name>
  <files>src/renderer/src/components/checkpoints/CheckpointList.tsx, src/renderer/src/components/checkpoints/CheckpointList.test.tsx, src/renderer/src/components/checkpoints/ReviewModal.tsx, src/renderer/src/components/checkpoints/ReviewModal.test.tsx, src/renderer/src/components/checkpoints/index.ts</files>
  <action>
**CheckpointList.tsx (~80 LOC):**

Display list of checkpoints with restore/delete actions:

```typescript
import { useCheckpoint } from '@renderer/hooks/useCheckpoint';
import { Button } from '@renderer/components/ui/button';
import { formatDistanceToNow } from 'date-fns';

interface CheckpointListProps {
  projectId: string;
}

export function CheckpointList({ projectId }: CheckpointListProps) {
  const {
    checkpoints,
    isLoading,
    loadCheckpoints,
    restoreCheckpoint,
    deleteCheckpoint,
    createCheckpoint,
  } = useCheckpoint();

  useEffect(() => {
    loadCheckpoints(projectId);
  }, [projectId, loadCheckpoints]);

  if (isLoading) {
    return <div className="p-4 text-muted-foreground">Loading checkpoints...</div>;
  }

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-semibold">Checkpoints</h3>
        <Button
          size="sm"
          onClick={() => createCheckpoint(projectId, 'Manual checkpoint')}
        >
          Create Checkpoint
        </Button>
      </div>

      {checkpoints.length === 0 ? (
        <p className="text-muted-foreground">No checkpoints yet</p>
      ) : (
        <ul className="space-y-2">
          {checkpoints.map((cp) => (
            <li
              key={cp.id}
              className="flex items-center justify-between p-3 border rounded-lg"
            >
              <div>
                <p className="font-medium">{cp.name || cp.reason}</p>
                <p className="text-sm text-muted-foreground">
                  {formatDistanceToNow(new Date(cp.createdAt), { addSuffix: true })}
                </p>
              </div>
              <div className="flex gap-2">
                <Button
                  size="sm"
                  variant="outline"
                  onClick={() => restoreCheckpoint(cp.id, true)}
                >
                  Restore
                </Button>
                <Button
                  size="sm"
                  variant="ghost"
                  onClick={() => deleteCheckpoint(cp.id)}
                >
                  Delete
                </Button>
              </div>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

**ReviewModal.tsx (~100 LOC):**

Modal for human review with approve/reject actions:

```typescript
import { useState } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from '@renderer/components/ui/dialog';
import { Button } from '@renderer/components/ui/button';
import { Textarea } from '@renderer/components/ui/textarea';
import type { HumanReviewRequest } from '@/orchestration/review/HumanReviewService';

interface ReviewModalProps {
  review: HumanReviewRequest | null;
  onApprove: (reviewId: string, resolution?: string) => Promise<void>;
  onReject: (reviewId: string, feedback: string) => Promise<void>;
}

export function ReviewModal({ review, onApprove, onReject }: ReviewModalProps) {
  const [feedback, setFeedback] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  if (!review) return null;

  const handleApprove = async () => {
    setIsSubmitting(true);
    try {
      await onApprove(review.id, feedback || undefined);
    } finally {
      setIsSubmitting(false);
      setFeedback('');
    }
  };

  const handleReject = async () => {
    if (!feedback.trim()) {
      return; // Require feedback for rejection
    }
    setIsSubmitting(true);
    try {
      await onReject(review.id, feedback);
    } finally {
      setIsSubmitting(false);
      setFeedback('');
    }
  };

  return (
    <Dialog open={!!review}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>Human Review Required</DialogTitle>
          <DialogDescription>
            {review.reason === 'qa_exhausted'
              ? `QA loop exhausted after ${review.context.qaIterations} iterations`
              : review.reason === 'merge_conflict'
              ? 'Merge conflict detected'
              : 'Manual review requested'}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          <div>
            <p className="text-sm font-medium">Task ID</p>
            <p className="text-sm text-muted-foreground font-mono">{review.taskId}</p>
          </div>

          {review.context.escalationReason && (
            <div>
              <p className="text-sm font-medium">Reason</p>
              <p className="text-sm text-muted-foreground">{review.context.escalationReason}</p>
            </div>
          )}

          {review.context.suggestedAction && (
            <div>
              <p className="text-sm font-medium">Suggested Action</p>
              <p className="text-sm text-muted-foreground">{review.context.suggestedAction}</p>
            </div>
          )}

          <div>
            <label className="text-sm font-medium">Feedback (required for rejection)</label>
            <Textarea
              value={feedback}
              onChange={(e) => setFeedback(e.target.value)}
              placeholder="Enter feedback or resolution notes..."
              className="mt-2"
            />
          </div>
        </div>

        <DialogFooter>
          <Button
            variant="outline"
            onClick={handleReject}
            disabled={isSubmitting || !feedback.trim()}
          >
            Reject
          </Button>
          <Button onClick={handleApprove} disabled={isSubmitting}>
            Approve
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

**Tests (~5 total):**
- CheckpointList renders checkpoints
- CheckpointList shows empty state
- CheckpointList calls restore on button click
- ReviewModal shows review details
- ReviewModal requires feedback for reject

**index.ts:**
```typescript
export { CheckpointList } from './CheckpointList';
export { ReviewModal } from './ReviewModal';
```
  </action>
  <verify>npm test src/renderer/src/components/checkpoints passes</verify>
  <done>CheckpointList and ReviewModal components created with tests</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes
- [ ] `npm test src/renderer/src/components/checkpoints` passes
- [ ] `npm run lint` passes for all new files
- [ ] IPC handlers properly exposed via preload
- [ ] Components use shadcn/ui patterns
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- IPC handlers enable renderer â†” main communication
- UI components display checkpoints and handle reviews
- Phase 10 complete
</success_criteria>

<output>
After completion, create `.planning/phases/10-human-checkpoints/10-03-SUMMARY.md`
</output>
