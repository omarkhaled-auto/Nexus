---
phase: 10-human-checkpoints
plan: 01
type: execute
depends_on: []
files_modified: [src/types/events.ts, src/orchestration/review/HumanReviewService.ts, src/orchestration/review/HumanReviewService.test.ts, src/orchestration/review/index.ts]
---

<objective>
Create HumanReviewService for managing review requests when QA escalates or critical operations need human approval.

Purpose: Build the core HITL (Human-in-the-Loop) gate system that blocks agent execution until human approves/rejects.
Output: HumanReviewService with review queue, EventBus integration, and persistence via sessions table.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-human-checkpoints/10-CONTEXT.md
@.planning/phases/10-human-checkpoints/10-RESEARCH.md
@src/orchestration/events/EventBus.ts
@src/types/events.ts
@src/persistence/database/schema.ts
@src/interview/InterviewSessionManager.ts

**Constraining decisions:**
- Phase 09-03: Sessions in sessions table with JSON - use same pattern for review persistence
- Phase 04-03: EventBus singleton pattern - integrate with existing EventBus

**Patterns from RESEARCH.md:**
- Gate-based approval (HITL) pattern
- Persist reviews to database for crash recovery
- Emit events for UI notification
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add review event types to events.ts</name>
  <files>src/types/events.ts</files>
  <action>
Add 3 new event types to EventType union:
- 'review:requested' - Human review needed
- 'review:approved' - Human approved action
- 'review:rejected' - Human rejected action

Add payload interfaces:
```typescript
export interface ReviewRequestedPayload {
  reviewId: string;
  taskId: string;
  reason: 'qa_exhausted' | 'merge_conflict' | 'manual_request';
  context: ReviewContext;
}

export interface ReviewContext {
  qaIterations?: number;
  escalationReason?: string;
  suggestedAction?: string;
}

export interface ReviewApprovedPayload {
  reviewId: string;
  resolution?: string;
}

export interface ReviewRejectedPayload {
  reviewId: string;
  feedback: string;
}
```

Add to EventPayloadMap for type safety.

IMPORTANT: Follow existing event type patterns exactly. Place review events in a new section after interview events.
  </action>
  <verify>npm run typecheck passes, events.ts has no lint errors</verify>
  <done>3 review event types added with payloads and mapped in EventPayloadMap</done>
</task>

<task type="auto">
  <name>Task 2: Create HumanReviewService with persistence</name>
  <files>src/orchestration/review/HumanReviewService.ts, src/orchestration/review/HumanReviewService.test.ts, src/orchestration/review/index.ts</files>
  <action>
Create HumanReviewService class (~150-200 LOC):

**Interfaces:**
```typescript
export type ReviewReason = 'qa_exhausted' | 'merge_conflict' | 'manual_request';
export type ReviewStatus = 'pending' | 'approved' | 'rejected';

export interface HumanReviewRequest {
  id: string;
  taskId: string;
  projectId: string;
  reason: ReviewReason;
  context: ReviewContext;
  status: ReviewStatus;
  createdAt: Date;
  resolvedAt?: Date;
  resolution?: string;
}

export interface CreateReviewOptions {
  taskId: string;
  projectId: string;
  reason: ReviewReason;
  context?: ReviewContext;
}
```

**Class structure:**
- Constructor takes: DatabaseClient, EventBus, CheckpointManager (optional)
- pendingReviews: Map<string, HumanReviewRequest> for in-memory cache
- Load pending reviews from DB on construction

**Methods:**
1. `requestReview(options: CreateReviewOptions): Promise<HumanReviewRequest>`
   - Generate UUID for review
   - Create HumanReviewRequest with status='pending'
   - Persist to sessions table (type='review', data=JSON.stringify(request))
   - If CheckpointManager provided, create safety checkpoint
   - Add to pendingReviews map
   - Emit 'review:requested' event
   - Return the request

2. `approveReview(reviewId: string, resolution?: string): Promise<void>`
   - Get from pendingReviews (throw ReviewNotFoundError if missing)
   - Update status='approved', resolvedAt=now, resolution
   - Update in sessions table
   - Remove from pendingReviews
   - Emit 'review:approved' event

3. `rejectReview(reviewId: string, feedback: string): Promise<void>`
   - Get from pendingReviews (throw ReviewNotFoundError if missing)
   - Update status='rejected', resolvedAt=now, resolution=feedback
   - Update in sessions table
   - Remove from pendingReviews
   - Emit 'review:rejected' event

4. `listPendingReviews(): HumanReviewRequest[]`
   - Return Array.from(pendingReviews.values())

5. `getReview(reviewId: string): HumanReviewRequest | undefined`
   - Return pendingReviews.get(reviewId)

**Persistence pattern (follow InterviewSessionManager):**
- Use sessions table with type='review'
- Store full HumanReviewRequest as JSON in data field
- On construction, load all pending reviews from DB

**Error classes:**
- ReviewNotFoundError extends Error
- ReviewAlreadyResolvedError extends Error

**Tests (~10):**
- requestReview creates review and emits event
- requestReview persists to database
- approveReview updates status and emits event
- rejectReview updates status with feedback
- listPendingReviews returns all pending
- getReview returns single review
- approveReview throws for unknown ID
- rejectReview throws for unknown ID
- reviews survive restart (load from DB on construction)
- creates checkpoint if CheckpointManager provided

Create index.ts to export HumanReviewService and types.
  </action>
  <verify>npm test src/orchestration/review passes with all tests green</verify>
  <done>HumanReviewService created with full CRUD, EventBus integration, persistence, and 10 passing tests</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes
- [ ] `npm test src/orchestration/review` passes all tests
- [ ] `npm run lint` passes for new files
- [ ] Review events properly typed in EventPayloadMap
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- HumanReviewService integrates with EventBus and persists to DB
- Review events emitted correctly
</success_criteria>

<output>
After completion, create `.planning/phases/10-human-checkpoints/10-01-SUMMARY.md`
</output>
