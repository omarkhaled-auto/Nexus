---
phase: 10-human-checkpoints
plan: 02
type: execute
depends_on: ["10-01"]
files_modified: [src/persistence/checkpoints/CheckpointScheduler.ts, src/persistence/checkpoints/CheckpointScheduler.test.ts, src/persistence/checkpoints/CheckpointManager.ts, src/persistence/checkpoints/CheckpointManager.test.ts, src/persistence/checkpoints/index.ts]
---

<objective>
Create CheckpointScheduler for automatic time-based and event-triggered checkpoints, and enhance CheckpointManager with EventBus integration and pruning.

Purpose: Enable automatic safety checkpoints at intervals, on feature completion, and on QA escalation.
Output: CheckpointScheduler service with configurable triggers, enhanced CheckpointManager with pruning.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-human-checkpoints/10-CONTEXT.md
@.planning/phases/10-human-checkpoints/10-RESEARCH.md
@.planning/phases/10-human-checkpoints/10-01-SUMMARY.md
@src/persistence/checkpoints/CheckpointManager.ts
@src/orchestration/events/EventBus.ts
@src/orchestration/review/HumanReviewService.ts

**Constraining decisions:**
- Phase 04-03: EventBus singleton pattern
- RESEARCH.md: Prune on create (keep N most recent)
- RESEARCH.md: Only QA exhausted triggers review, not time-based checkpoints

**Patterns from RESEARCH.md:**
- Scheduled checkpoints pattern
- setInterval with cleanup on stop
- Event-based triggers via EventBus subscription
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance CheckpointManager with EventBus and pruning</name>
  <files>src/persistence/checkpoints/CheckpointManager.ts, src/persistence/checkpoints/CheckpointManager.test.ts</files>
  <action>
Enhance existing CheckpointManager:

**Add to constructor options:**
```typescript
export interface CheckpointManagerOptions {
  db: DatabaseClient;
  stateManager: StateManager;
  gitService: GitService;
  eventBus?: EventBus;  // NEW - optional EventBus
  maxCheckpoints?: number;  // NEW - default 50
  logger?: Logger;
}
```

**Add maxCheckpoints property:**
- Default: 50
- Store in constructor

**Add pruneOldCheckpoints method:**
```typescript
pruneOldCheckpoints(projectId: string): number {
  // Get all checkpoints for project ordered by createdAt DESC
  const allCheckpoints = this.listCheckpoints(projectId);

  // If count <= maxCheckpoints, nothing to prune
  if (allCheckpoints.length <= this.maxCheckpoints) {
    return 0;
  }

  // Delete checkpoints beyond maxCheckpoints (oldest ones)
  const toDelete = allCheckpoints.slice(this.maxCheckpoints);
  for (const cp of toDelete) {
    this.deleteCheckpoint(cp.id);
  }

  return toDelete.length;
}
```

**Enhance createCheckpoint:**
- After inserting new checkpoint, call pruneOldCheckpoints
- If eventBus provided, emit 'system:checkpoint-created' event with payload:
  ```typescript
  {
    checkpointId: checkpoint.id,
    projectId,
    reason,
    gitCommit: checkpoint.gitCommit ?? ''
  }
  ```

**Enhance restoreCheckpoint:**
- If eventBus provided, emit 'system:checkpoint-restored' event

**Add new tests (~5):**
- pruneOldCheckpoints removes oldest when over limit
- pruneOldCheckpoints does nothing when under limit
- createCheckpoint emits event when eventBus provided
- restoreCheckpoint emits event when eventBus provided
- createCheckpoint auto-prunes after insert
  </action>
  <verify>npm test src/persistence/checkpoints/CheckpointManager.test.ts passes</verify>
  <done>CheckpointManager enhanced with EventBus integration and auto-pruning</done>
</task>

<task type="auto">
  <name>Task 2: Create CheckpointScheduler with time and event triggers</name>
  <files>src/persistence/checkpoints/CheckpointScheduler.ts, src/persistence/checkpoints/CheckpointScheduler.test.ts</files>
  <action>
Create CheckpointScheduler class (~100-150 LOC):

**Interfaces:**
```typescript
export interface CheckpointConfig {
  autoCheckpointInterval: number;  // Default: 7200000 (2 hours in ms)
  maxCheckpoints: number;          // Default: 50
  checkpointOnFeatureComplete: boolean; // Default: true
  checkpointBeforeRiskyOps: boolean;    // Default: true
}

export interface CheckpointSchedulerOptions {
  checkpointManager: CheckpointManager;
  humanReviewService: HumanReviewService;
  eventBus: EventBus;
  config?: Partial<CheckpointConfig>;
  logger?: Logger;
}
```

**Class structure:**
- Private intervalId: NodeJS.Timeout | null
- Private unsubscribers: Unsubscribe[] for EventBus listeners
- Private config: CheckpointConfig (merge defaults with provided)
- Private activeProjectId: string | null

**Methods:**

1. `start(projectId: string): void`
   - Store projectId as activeProjectId
   - Set up time-based interval:
     ```typescript
     this.intervalId = setInterval(
       () => this.createScheduledCheckpoint('scheduled'),
       this.config.autoCheckpointInterval
     );
     ```
   - Subscribe to EventBus events:
     - 'feature:completed' → if checkpointOnFeatureComplete, create checkpoint
     - 'task:escalated' → create checkpoint + request review via HumanReviewService

2. `stop(): void`
   - Clear interval if exists
   - Call all unsubscribers
   - Set activeProjectId to null

3. `private createScheduledCheckpoint(trigger: AutoCheckpointTrigger): Promise<void>`
   - If no activeProjectId, return early
   - Call checkpointManager.createAutoCheckpoint(activeProjectId, trigger)
   - Log creation

4. `isRunning(): boolean`
   - Return intervalId !== null

5. `getConfig(): CheckpointConfig`
   - Return copy of config

**Event handling:**
- On 'task:escalated':
  ```typescript
  await this.createScheduledCheckpoint('qa_exhausted');
  await this.humanReviewService.requestReview({
    taskId: event.payload.taskId,
    projectId: this.activeProjectId!,
    reason: 'qa_exhausted',
    context: {
      qaIterations: event.payload.iterations,
      escalationReason: event.payload.reason
    }
  });
  ```

**Tests (~8):**
- start() begins interval
- stop() clears interval
- isRunning() reflects state
- creates checkpoint on interval (use fake timers)
- creates checkpoint on feature:completed event
- creates checkpoint + requests review on task:escalated event
- respects checkpointOnFeatureComplete config
- uses default config values

Create tests using vitest's fake timers (vi.useFakeTimers, vi.advanceTimersByTime).
  </action>
  <verify>npm test src/persistence/checkpoints/CheckpointScheduler.test.ts passes</verify>
  <done>CheckpointScheduler created with time-based and event-based triggers, 8 passing tests</done>
</task>

<task type="auto">
  <name>Task 3: Update checkpoints index exports</name>
  <files>src/persistence/checkpoints/index.ts</files>
  <action>
Update index.ts to export new components:

```typescript
export { CheckpointManager } from './CheckpointManager';
export type {
  CheckpointManagerOptions,
  RestoreOptions,
  Logger,
  AutoCheckpointTrigger
} from './CheckpointManager';
export {
  CheckpointError,
  CheckpointNotFoundError,
  RestoreError
} from './CheckpointManager';

export { CheckpointScheduler } from './CheckpointScheduler';
export type {
  CheckpointConfig,
  CheckpointSchedulerOptions
} from './CheckpointScheduler';
```

Ensure all public types and classes are exported.
  </action>
  <verify>npm run typecheck passes, can import from '@/persistence/checkpoints'</verify>
  <done>Checkpoints index exports all new components</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes
- [ ] `npm test src/persistence/checkpoints` passes all tests
- [ ] `npm run lint` passes for modified files
- [ ] CheckpointScheduler integrates with EventBus and HumanReviewService
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- CheckpointManager emits events and prunes old checkpoints
- CheckpointScheduler responds to time and events
</success_criteria>

<output>
After completion, create `.planning/phases/10-human-checkpoints/10-02-SUMMARY.md`
</output>
