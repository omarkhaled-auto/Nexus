---
phase: 04-orchestration
plan: 02
type: tdd
depends_on: ["04-01"]
files_modified: [src/orchestration/coordinator/NexusCoordinator.ts, src/orchestration/coordinator/NexusCoordinator.test.ts, src/orchestration/agents/AgentPool.ts, src/orchestration/agents/AgentPool.test.ts, src/orchestration/queue/TaskQueue.ts, src/orchestration/queue/TaskQueue.test.ts, src/orchestration/types.ts, src/orchestration/index.ts]
---

<objective>
Implement core orchestration components: NexusCoordinator, AgentPool, and TaskQueue using TDD.

Purpose: Create the central coordination system that manages multi-agent execution with wave-based task scheduling.
Output: Working orchestrator that coordinates up to 4 agents processing tasks in dependency-ordered waves.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
./.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-orchestration/04-01-SUMMARY.md
@src/planning/index.ts
@src/execution/agents/AgentRunner.ts
@src/execution/qa-loop/QALoopEngine.ts
@src/infrastructure/git/WorktreeManager.ts

**Tech stack available:** TypeScript, Vitest
**Established patterns:** TDD, async generators, tool loop

**From 04-01:**
- TaskDecomposer for feature breakdown
- DependencyResolver for wave calculation
- TimeEstimator for duration estimates

**From Phase 3:**
- AgentRunner (CoderRunner, TesterRunner, etc.)
- QALoopEngine for task execution
- WorktreeManager for agent isolation

**Master Book BUILD-012 spec (28h):**
- NexusCoordinator: Main orchestration entry point, Genesis/Evolution modes
- AgentPool: Spawn and manage up to 4 agents, worktree assignment
- TaskQueue: Priority queue with dependency awareness, wave-based scheduling

**Interfaces from Architecture:**
```typescript
interface INexusCoordinator {
  initialize(config: ProjectConfig): Promise<void>;
  start(projectId: string): Promise<void>;
  pause(reason?: string): Promise<void>;
  resume(): Promise<void>;
  stop(): Promise<void>;
  getStatus(): CoordinatorStatus;
  getProgress(): ProjectProgress;
  getActiveAgents(): Agent[];
  getPendingTasks(): Task[];
  onEvent(handler: (event: NexusEvent) => void): void;
  createCheckpoint(name?: string): Promise<Checkpoint>;
}

interface CoordinatorStatus {
  state: 'idle' | 'running' | 'paused' | 'stopping';
  projectId?: string;
  activeAgents: number;
  queuedTasks: number;
  completedTasks: number;
  currentPhase: 'interview' | 'planning' | 'execution' | 'review';
}
```
</context>

<feature>
  <name>TaskQueue - Priority Queue with Wave Awareness</name>
  <files>src/orchestration/types.ts, src/orchestration/queue/TaskQueue.ts, src/orchestration/queue/TaskQueue.test.ts</files>
  <behavior>
    TaskQueue manages task scheduling with dependency and wave awareness.

    **enqueue(task, wave?) -> void**:
    - Adds task to queue
    - Associates with wave if provided
    - Tasks sorted by wave, then priority

    **dequeue() -> Task | null**:
    - Returns next ready task (all dependencies met)
    - Returns null if no ready tasks
    - Respects wave ordering

    **peek() -> Task | null**:
    - Returns next task without removing

    **markComplete(taskId) -> void**:
    - Marks task as complete
    - Updates dependency tracking for dependent tasks

    **getReadyTasks() -> Task[]**:
    - Returns all tasks whose dependencies are complete

    **getByWave(waveId) -> Task[]**:
    - Returns tasks in specific wave

    **Test cases (10+ tests):**
    - enqueue() adds task to queue
    - dequeue() returns task with no dependencies first
    - dequeue() returns null when dependencies unmet
    - markComplete() enables dependent task dequeue
    - Wave 0 tasks dequeue before Wave 1 tasks
    - getReadyTasks() returns multiple parallel tasks
    - Empty queue returns null
    - Priority ordering within same wave
    - size() returns correct count
    - clear() empties queue
  </behavior>
  <implementation>
    Use Map<taskId, Task> for storage.
    Track completedTaskIds: Set<string>.
    Sort by: wave ASC, priority DESC, createdAt ASC.
    Ready check: all task.dependsOn in completedTaskIds.
  </implementation>
</feature>

<feature>
  <name>AgentPool - Multi-Agent Management</name>
  <files>src/orchestration/agents/AgentPool.ts, src/orchestration/agents/AgentPool.test.ts</files>
  <behavior>
    AgentPool manages agent lifecycle with max 4 concurrent agents.

    **spawn(type: AgentType) -> Agent**:
    - Creates new agent of specified type
    - Assigns unique ID
    - Throws if pool at capacity (4)

    **getAvailable() -> Agent | null**:
    - Returns idle agent
    - Returns null if all busy

    **assign(agentId, taskId, worktreePath) -> void**:
    - Associates agent with task
    - Updates agent state to 'assigned'

    **release(agentId) -> void**:
    - Returns agent to idle state
    - Available for next task

    **terminate(agentId) -> void**:
    - Removes agent from pool
    - Cleans up resources

    **getAll() -> Agent[]**:
    - Returns all agents in pool

    **getActive() -> Agent[]**:
    - Returns non-idle agents

    **Test cases (12+ tests):**
    - spawn() creates agent with ID
    - spawn() throws at max capacity (4)
    - getAvailable() returns idle agent
    - getAvailable() returns null when all assigned
    - assign() updates agent state
    - release() makes agent available again
    - terminate() removes from pool
    - Multiple agent types can coexist
    - Agent state transitions correct
    - Pool tracks correct count
    - getActive() excludes idle agents
  </behavior>
  <implementation>
    Use Map<agentId, Agent> for storage.
    Agent states: 'idle' | 'assigned' | 'running' | 'terminated'.
    Max pool size constant: MAX_AGENTS = 4.
    Generate IDs with nanoid or crypto.randomUUID().
  </implementation>
</feature>

<feature>
  <name>NexusCoordinator - Main Orchestration Loop</name>
  <files>src/orchestration/coordinator/NexusCoordinator.ts, src/orchestration/coordinator/NexusCoordinator.test.ts</files>
  <behavior>
    NexusCoordinator is the main orchestration entry point.

    **initialize(config) -> void**:
    - Sets up coordinator with config
    - Injects dependencies (decomposer, resolver, pool, queue)

    **start(projectId) -> void**:
    - Starts orchestration for project
    - Decomposes features into tasks
    - Calculates waves
    - Begins execution loop

    **orchestrate() (internal)**:
    - Main loop: for each wave
      - Queue all wave tasks
      - While wave not complete:
        - Get available agent
        - Dequeue ready task
        - Execute task with QA loop
        - Handle success/failure
      - Checkpoint after wave

    **pause(reason?) -> void**:
    - Pauses execution gracefully
    - Completes current task before pausing

    **resume() -> void**:
    - Resumes from paused state

    **stop() -> void**:
    - Stops execution
    - Terminates agents
    - Cleanup

    **Test cases (20+ tests):**
    - initialize() sets up dependencies
    - start() begins orchestration
    - getStatus() returns correct state
    - pause() transitions to paused
    - resume() continues from paused
    - stop() terminates cleanly
    - Wave processing completes before next wave
    - Agent assignment works correctly
    - Task completion updates state
    - Failed task triggers re-queue or escalation
    - Events emitted for state changes
    - Checkpoint created after each wave
    - Multiple agents work in parallel
    - Progress tracking accurate
  </behavior>
  <implementation>
    Constructor injects: TaskDecomposer, DependencyResolver, AgentPool, TaskQueue, QALoopEngine, WorktreeManager, CheckpointManager.
    Main loop uses async/await with polling for available agents.
    State machine: idle → running → paused → running → stopping → idle.
    Emit events via callback (EventBus integration in 04-03).
  </implementation>
</feature>

<verification>
- [ ] `pnpm test -- --testNamePattern "TaskQueue"` - 10+ tests pass
- [ ] `pnpm test -- --testNamePattern "AgentPool"` - 12+ tests pass
- [ ] `pnpm test -- --testNamePattern "NexusCoordinator"` - 20+ tests pass
- [ ] `pnpm typecheck` - no TypeScript errors
- [ ] `pnpm eslint src/orchestration/` - no lint errors
</verification>

<success_criteria>
- TaskQueue respects dependencies and waves
- AgentPool manages up to 4 concurrent agents
- NexusCoordinator orchestrates full execution flow
- 42+ total tests covering all behavior
- RED-GREEN-REFACTOR commits present
- Multi-agent coordination works
</success_criteria>

<output>
After completion, create `.planning/phases/04-orchestration/04-02-SUMMARY.md`:

# Phase 04-02: Orchestration Core Summary

**[Substantive one-liner]**

## TDD Metrics
| Component | Tests | Status |
|-----------|-------|--------|
| TaskQueue | N | PASS |
| AgentPool | N | PASS |
| NexusCoordinator | N | PASS |
| **Total** | **N** | **ALL PASS** |

## Components Implemented
- TaskQueue with wave-aware scheduling
- AgentPool with max 4 agents
- NexusCoordinator main loop

## Files Created
- src/orchestration/types.ts
- src/orchestration/queue/TaskQueue.ts
- src/orchestration/agents/AgentPool.ts
- src/orchestration/coordinator/NexusCoordinator.ts
- src/orchestration/index.ts
- Tests for each component

## Next Step
Ready for 04-03-PLAN.md (EventBus + Bridges)
</output>
