---
phase: 04-orchestration
plan: 03
type: tdd
depends_on: ["04-01", "04-02"]
files_modified: [src/orchestration/events/EventBus.ts, src/orchestration/events/EventBus.test.ts, src/bridges/AgentWorktreeBridge.ts, src/bridges/AgentWorktreeBridge.test.ts, src/bridges/PlanningExecutionBridge.ts, src/bridges/PlanningExecutionBridge.test.ts, src/bridges/index.ts]
---

<objective>
Implement EventBus for cross-layer communication and integration bridges using TDD.

Purpose: Enable decoupled event-driven communication across all layers and provide integration points between Planning and Execution layers.
Output: EventBus singleton with typed events, plus bridges connecting orchestration components.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
./.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-orchestration/04-01-SUMMARY.md
@.planning/phases/04-orchestration/04-02-SUMMARY.md
@src/types/events.ts
@src/orchestration/index.ts
@src/planning/index.ts
@src/infrastructure/git/WorktreeManager.ts

**Tech stack available:** TypeScript, Vitest
**Established patterns:** TDD, singleton pattern

**From 04-01:**
- TaskDecomposer, DependencyResolver available

**From 04-02:**
- NexusCoordinator, AgentPool, TaskQueue available

**Event types already defined:**
src/types/events.ts has 48 event types with full payload definitions.

**Master Book BUILD-012 spec:**
- EventBus: Cross-layer event communication, subscriber management
- AgentWorktreeBridge: Connect agents to worktrees
- PlanningExecutionBridge: Connect planning to execution

**Interfaces from Architecture:**
```typescript
interface IEventBus {
  emit<T extends EventType>(type: T, payload: EventPayload<T>): void;
  on<T extends EventType>(type: T, handler: EventHandler<T>): Unsubscribe;
  once<T extends EventType>(type: T, handler: EventHandler<T>): Unsubscribe;
  off<T extends EventType>(type: T, handler: EventHandler<T>): void;
  onAny(handler: WildcardHandler): Unsubscribe;
  removeAllListeners(type?: EventType): void;
  listenerCount(type: EventType): number;
}
```
</context>

<feature>
  <name>EventBus - Cross-Layer Event Communication</name>
  <files>src/orchestration/events/EventBus.ts, src/orchestration/events/EventBus.test.ts</files>
  <behavior>
    EventBus is a singleton that manages typed event subscriptions across all layers.

    **emit(type, payload) -> void**:
    - Creates NexusEvent with id, timestamp, type, payload
    - Calls all registered handlers for that event type
    - Calls all wildcard handlers
    - Does NOT throw if no handlers

    **on(type, handler) -> Unsubscribe**:
    - Registers handler for event type
    - Returns unsubscribe function
    - Handler receives full NexusEvent object

    **once(type, handler) -> Unsubscribe**:
    - Like on() but auto-removes after first call

    **off(type, handler) -> void**:
    - Removes specific handler
    - Silently ignores if not registered

    **onAny(handler) -> Unsubscribe**:
    - Registers wildcard handler for ALL events

    **removeAllListeners(type?) -> void**:
    - If type: removes handlers for that type
    - If no type: removes ALL handlers

    **listenerCount(type) -> number**:
    - Returns handler count for event type

    **getInstance() -> EventBus**:
    - Returns singleton instance

    **Test cases (15+ tests):**
    - emit() calls registered handlers with correct event shape
    - emit() with no handlers doesn't throw
    - on() returns working unsubscribe function
    - once() handler only fires once
    - off() removes correct handler
    - onAny() receives all event types
    - removeAllListeners() clears specific type
    - removeAllListeners() clears all
    - listenerCount() accurate
    - Multiple handlers all fire
    - Handler errors don't break other handlers
    - Singleton returns same instance
    - Event has correct shape (id, type, timestamp, payload)
    - Type safety enforced (correct payload type)
  </behavior>
  <implementation>
    Singleton pattern with private constructor.
    Use Map<EventType, Set<Handler>> for type handlers.
    Use Set<WildcardHandler> for wildcard handlers.
    Generate event IDs with crypto.randomUUID().
    Wrap handler calls in try-catch for error isolation.
    Types imported from @/types/events.
  </implementation>
</feature>

<feature>
  <name>AgentWorktreeBridge - Agent to Worktree Connection</name>
  <files>src/bridges/AgentWorktreeBridge.ts, src/bridges/AgentWorktreeBridge.test.ts</files>
  <behavior>
    AgentWorktreeBridge connects agents to isolated git worktrees.

    **assignWorktree(agentId, taskId) -> WorktreeInfo**:
    - Creates worktree for task via WorktreeManager
    - Associates worktree with agent
    - Returns worktree path and branch

    **releaseWorktree(agentId) -> void**:
    - Removes worktree association
    - Optionally cleans up worktree (configurable)

    **getWorktree(agentId) -> WorktreeInfo | null**:
    - Returns worktree info for agent
    - Null if agent has no worktree

    **getAllAssignments() -> Map<agentId, WorktreeInfo>**:
    - Returns all agent-worktree assignments

    **Test cases (8+ tests):**
    - assignWorktree() creates worktree
    - assignWorktree() returns correct info
    - releaseWorktree() removes assignment
    - getWorktree() returns null for unassigned
    - Multiple agents have separate worktrees
    - Worktree branch follows pattern: nexus/task/{taskId}/{timestamp}
    - Error handling for WorktreeManager failures
    - getAllAssignments() accurate
  </behavior>
  <implementation>
    Inject WorktreeManager.
    Track assignments in Map<agentId, WorktreeInfo>.
    Branch pattern: `nexus/task/${taskId}/${Date.now()}`.
    Emit events: 'agent:assigned' when worktree assigned.
  </implementation>
</feature>

<feature>
  <name>PlanningExecutionBridge - Plan to Execute Connection</name>
  <files>src/bridges/PlanningExecutionBridge.ts, src/bridges/PlanningExecutionBridge.test.ts</files>
  <behavior>
    PlanningExecutionBridge connects planning layer output to execution layer input.

    **submitPlan(waves: Wave[]) -> ExecutionHandle**:
    - Queues all tasks from waves into TaskQueue
    - Returns handle for tracking execution
    - Sets up wave completion callbacks

    **getExecutionStatus(handleId) -> ExecutionStatus**:
    - Returns current wave, completed tasks, pending tasks

    **onWaveComplete(callback) -> Unsubscribe**:
    - Registers callback for wave completion

    **onPlanComplete(callback) -> Unsubscribe**:
    - Registers callback for full plan completion

    **abort(handleId) -> void**:
    - Stops execution of plan
    - Marks remaining tasks as cancelled

    **Test cases (10+ tests):**
    - submitPlan() queues all tasks
    - submitPlan() returns valid handle
    - getExecutionStatus() returns correct counts
    - onWaveComplete() fires after wave done
    - onPlanComplete() fires after all waves
    - abort() cancels pending tasks
    - Multiple plans can run (different handles)
    - Wave ordering preserved
    - Error handling for queue failures
    - Proper cleanup on abort
  </behavior>
  <implementation>
    Inject TaskQueue, EventBus.
    Track executions in Map<handleId, ExecutionContext>.
    Subscribe to 'task:completed' events to track progress.
    Calculate wave completion from task completion events.
  </implementation>
</feature>

<verification>
- [ ] `pnpm test -- --testNamePattern "EventBus"` - 15+ tests pass
- [ ] `pnpm test -- --testNamePattern "AgentWorktreeBridge"` - 8+ tests pass
- [ ] `pnpm test -- --testNamePattern "PlanningExecutionBridge"` - 10+ tests pass
- [ ] `pnpm typecheck` - no TypeScript errors
- [ ] `pnpm eslint src/orchestration/events src/bridges` - no lint errors
</verification>

<success_criteria>
- EventBus provides type-safe pub/sub
- AgentWorktreeBridge manages agent isolation
- PlanningExecutionBridge connects planning to execution
- 33+ total tests covering all behavior
- RED-GREEN-REFACTOR commits present
- BUILD-012 complete
- Phase 4 complete: Orchestration layer ready
</success_criteria>

<output>
After completion, create `.planning/phases/04-orchestration/04-03-SUMMARY.md`:

# Phase 04-03: EventBus + Bridges Summary

**[Substantive one-liner]**

## TDD Metrics
| Component | Tests | Status |
|-----------|-------|--------|
| EventBus | N | PASS |
| AgentWorktreeBridge | N | PASS |
| PlanningExecutionBridge | N | PASS |
| **Total** | **N** | **ALL PASS** |

## Components Implemented
- EventBus singleton with typed events
- AgentWorktreeBridge for worktree isolation
- PlanningExecutionBridge for plan-to-execution flow

## Files Created
- src/orchestration/events/EventBus.ts
- src/bridges/AgentWorktreeBridge.ts
- src/bridges/PlanningExecutionBridge.ts
- src/bridges/index.ts
- Tests for each component

## Phase 4 Complete
Orchestration layer ready:
- **BUILD-011**: TaskDecomposer, DependencyResolver, TimeEstimator
- **BUILD-012**: NexusCoordinator, AgentPool, TaskQueue, EventBus, Bridges

**Success Criteria Met:**
- Task decomposition produces valid 30-min tasks
- Dependency resolution detects cycles, calculates waves
- Multiple agents coordinate in parallel
- Events flow through system

## Next Phase
Ready for Phase 5: UI Foundation (BUILD-013)
</output>
