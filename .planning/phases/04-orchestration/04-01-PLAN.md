---
phase: 04-orchestration
plan: 01
type: tdd
depends_on: []
files_modified: [src/planning/decomposition/TaskDecomposer.ts, src/planning/decomposition/TaskDecomposer.test.ts, src/planning/dependencies/DependencyResolver.ts, src/planning/dependencies/DependencyResolver.test.ts, src/planning/estimation/TimeEstimator.ts, src/planning/estimation/TimeEstimator.test.ts, src/planning/types.ts, src/planning/index.ts]
---

<objective>
Implement Planning Layer (BUILD-011) with TaskDecomposer, DependencyResolver, and TimeEstimator using TDD.

Purpose: Enable intelligent task decomposition from features into 30-minute atomic tasks, resolve dependencies using topological sort, and calculate parallel execution waves.
Output: Complete planning layer that decomposes features into dependency-ordered task waves.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
./.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@src/types/task.ts
@src/types/core.ts
@src/llm/LLMProvider.ts

**Tech stack available:** TypeScript, Vitest, LLMProvider
**Established patterns:** TDD (RED-GREEN-REFACTOR), tool loop pattern

**From Phase 3:**
- LLMProvider available for AI-assisted decomposition
- AgentRunner pattern for async operations

**Master Book BUILD-011 spec (20h):**
- TaskDecomposer: Feature → SubFeature → Task, 30-min limit enforcement
- DependencyResolver: Topological sort, cycle detection, wave calculation
- TimeEstimator: AI-based estimation, historical calibration

**Interfaces from Architecture:**
```typescript
interface ITaskDecomposer {
  decompose(feature: Feature): Promise<Task[]>;
  decomposeSubFeature(subFeature: SubFeature): Promise<Task[]>;
  validateTaskSize(task: Task): ValidationResult;
  splitTask(task: Task): Promise<Task[]>;
  estimateTime(task: Task): number;
}

interface IDependencyResolver {
  resolve(tasks: Task[]): Promise<DependencyGraph>;
  topologicalSort(tasks: Task[]): Task[];
  detectCycles(tasks: Task[]): Cycle[];
  calculateWaves(tasks: Task[]): Wave[];
}

interface Wave {
  id: number;
  tasks: Task[];
  estimatedTime: number;
  dependencies: number[];
}
```
</context>

<feature>
  <name>TaskDecomposer - Feature to Task Breakdown</name>
  <files>src/planning/types.ts, src/planning/decomposition/TaskDecomposer.ts, src/planning/decomposition/TaskDecomposer.test.ts</files>
  <behavior>
    TaskDecomposer uses LLM to intelligently break features into atomic tasks.

    **decompose(feature) -> Task[]**:
    - Analyzes feature description using LLM
    - Breaks into SubFeatures if complex
    - Creates atomic tasks (5-30 min each)
    - Enforces 30-minute maximum per task
    - Auto-splits tasks exceeding limit

    **validateTaskSize(task) -> ValidationResult**:
    - Checks estimated time <= 30 min
    - Validates clear scope (single file/concern)
    - Checks for test criteria presence
    - Returns issues with suggestions

    **splitTask(task) -> Task[]**:
    - Splits oversized task into smaller ones
    - Uses LLM to determine logical boundaries
    - Preserves dependencies between split tasks

    **Test cases (12+ tests):**
    - decompose() creates tasks from simple feature
    - decompose() breaks complex feature into SubFeatures first
    - All generated tasks have timeEstimate <= 30
    - validateTaskSize() rejects 45-min task as too_large
    - validateTaskSize() accepts 25-min task
    - splitTask() divides 60-min task into two ~30-min tasks
    - Tasks have proper dependency chains after split
    - Error handling when LLM fails
    - Empty feature returns empty task list
  </behavior>
  <implementation>
    Create src/planning/ directory structure.
    TaskDecomposer uses LLMProvider for AI decomposition.
    Prompt LLM with feature description, get structured JSON response.
    Validate each task, auto-split if needed.
    Track parent-child relationships in task.parentTaskId.
  </implementation>
</feature>

<feature>
  <name>DependencyResolver - Topological Sort and Waves</name>
  <files>src/planning/dependencies/DependencyResolver.ts, src/planning/dependencies/DependencyResolver.test.ts</files>
  <behavior>
    DependencyResolver analyzes task dependencies and creates parallel execution waves.

    **resolve(tasks) -> DependencyGraph**:
    - Builds adjacency list from task.dependsOn
    - Returns graph structure for visualization

    **topologicalSort(tasks) -> Task[]**:
    - Implements Kahn's algorithm
    - Returns tasks in valid execution order
    - Throws CycleError if cycle detected

    **detectCycles(tasks) -> Cycle[]**:
    - Returns all cycles found in dependency graph
    - Each Cycle contains array of task IDs in cycle

    **calculateWaves(tasks) -> Wave[]**:
    - Groups tasks that can run in parallel
    - Wave N contains tasks whose dependencies are all in Waves 0 to N-1
    - Calculates estimatedTime per wave (max of task times)

    **Test cases (15+ tests):**
    - topologicalSort() orders A→B→C correctly
    - topologicalSort() throws on cycle A→B→A
    - detectCycles() finds single cycle
    - detectCycles() finds multiple cycles
    - calculateWaves() puts independent tasks in Wave 0
    - calculateWaves() puts dependent tasks in later waves
    - Wave estimatedTime is max of task times
    - Empty task list returns empty waves
    - Single task returns single wave
    - Complex graph with multiple paths resolves correctly
  </behavior>
  <implementation>
    Pure TypeScript implementation (no LLM needed).
    Use Map<taskId, Set<dependencyId>> for graph.
    Kahn's algorithm: BFS from nodes with no incoming edges.
    Wave calculation: BFS with level tracking.
  </implementation>
</feature>

<feature>
  <name>TimeEstimator - AI-Based Estimation</name>
  <files>src/planning/estimation/TimeEstimator.ts, src/planning/estimation/TimeEstimator.test.ts</files>
  <behavior>
    TimeEstimator uses LLM and historical data to estimate task duration.

    **estimateTime(task) -> number**:
    - Analyzes task description with LLM
    - Returns estimated minutes (5-30)
    - Uses task complexity signals

    **estimateFeature(feature) -> FeatureEstimate**:
    - Decomposes feature, estimates each task
    - Returns total time and confidence

    **calibrate(history: CompletedTask[]) -> void**:
    - Adjusts estimates based on actual completion times
    - Stores calibration factor

    **Test cases (8+ tests):**
    - estimateTime() returns 5-30 minute range
    - Simple CRUD task estimates ~15 min
    - Complex algorithm task estimates ~30 min
    - estimateFeature() sums task estimates
    - calibrate() adjusts for underestimation
    - calibrate() adjusts for overestimation
    - Default calibration factor is 1.0
  </behavior>
  <implementation>
    Uses LLMProvider for AI estimation.
    Prompt includes task description and complexity signals.
    Store calibration factor in memory (later: persist to DB).
    Cap estimates at 30 min (task should be split if more).
  </implementation>
</feature>

<verification>
- [ ] `pnpm test -- --testNamePattern "TaskDecomposer"` - 12+ tests pass
- [ ] `pnpm test -- --testNamePattern "DependencyResolver"` - 15+ tests pass
- [ ] `pnpm test -- --testNamePattern "TimeEstimator"` - 8+ tests pass
- [ ] `pnpm typecheck` - no TypeScript errors
- [ ] `pnpm eslint src/planning/` - no lint errors
</verification>

<success_criteria>
- TaskDecomposer breaks features into ≤30-min tasks
- DependencyResolver correctly sorts and calculates waves
- TimeEstimator provides reasonable estimates
- 35+ total tests covering all behavior
- RED-GREEN-REFACTOR commits present
- BUILD-011 complete
</success_criteria>

<output>
After completion, create `.planning/phases/04-orchestration/04-01-SUMMARY.md`:

# Phase 04-01: Planning Layer Summary

**[Substantive one-liner]**

## TDD Metrics
| Component | Tests | Status |
|-----------|-------|--------|
| TaskDecomposer | N | PASS |
| DependencyResolver | N | PASS |
| TimeEstimator | N | PASS |
| **Total** | **N** | **ALL PASS** |

## Components Implemented
- TaskDecomposer with AI decomposition
- DependencyResolver with Kahn's algorithm
- TimeEstimator with calibration

## Files Created
- src/planning/types.ts
- src/planning/decomposition/TaskDecomposer.ts
- src/planning/dependencies/DependencyResolver.ts
- src/planning/estimation/TimeEstimator.ts
- src/planning/index.ts
- Tests for each component

## Next Step
Ready for 04-02-PLAN.md (NexusCoordinator + AgentPool + TaskQueue)
</output>
